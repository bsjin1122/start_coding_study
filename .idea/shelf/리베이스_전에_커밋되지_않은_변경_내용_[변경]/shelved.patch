Index: src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,35 +0,0 @@
-package bsjin1122.BOJ.week01;
-
-import java.util.Scanner;
-import java.util.Stack;
-
-// 쇠막대기
-public class BOJ_10799 {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner(System.in);
-
-        String input = sc.next();
-
-        int result = 0;
-
-        Stack<Character> stack = new Stack<>();
-
-        for(int i =0; i<input.length(); i++){
-            if(input.charAt(i) == '('){
-                stack.push('(');
-            }else if(input.charAt(i)==')'){
-                stack.pop();
-            }
-
-            if(i >0){
-                if(input.charAt(i-1) == '(' && input.charAt(i) ==')'){
-                    result += stack.size();
-                }else if(input.charAt(i-1) == ')' && input.charAt(i) == ')'){
-                    result++;
-                }
-            }
-        }
-        System.out.println(result);
-    }
-}
-
Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,57 +0,0 @@
-package bsjin1122.BOJ.week01;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Stack;
-
-// 단어뒤집기2
-public class BOJ_17413 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-
-        String str = br.readLine(); // 문자열 S입력
-        StringBuilder sb = new StringBuilder(); // 결과 값을 출력할 StringBuilder
-        Stack<Character> stack = new Stack <> (); // 후입선출 기능을 이용하기 위한 자료구조 Stack
-        boolean flag = false;
-
-        for(int i =0; i < str.length(); i++){
-            if(str.charAt(i) == '<'){
-                while(!stack.isEmpty()){
-                    sb.append(stack.pop());
-                }
-                flag = true;
-            }
-            else if(str.charAt(i) == '>'){
-                flag = false;
-                sb.append(str.charAt(i));
-                continue;
-            }
-
-            if(flag == true){
-                sb.append(str.charAt(i));
-            }else if(flag == false) {
-                if (str.charAt(i) == ' ') {
-                    while (!stack.isEmpty()) {
-                        sb.append(stack.pop());
-                    }
-                    sb.append(' ');
-                    continue;
-                } else {
-                    stack.push(str.charAt(i));
-                }
-            }
-
-            if(i == str.length() - 1){
-                while (!stack.isEmpty()) {
-                    sb.append(stack.pop());
-                }
-            }
-        }
-        // 결과문 출력
-        System.out.println(sb);
-
-
-    }
-}
Index: src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,74 +0,0 @@
-package bsjin1122.BOJ.week02;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Scanner;
-import java.util.StringTokenizer;
-
-public class BOJ_1934 {
-    /**
-     * @author bsjin
-     * @date 2023/12/25
-     * @title 백준 1934 최소공배수
-     *
-     * 문제
-     * 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다.
-     * 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
-     * 두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
-     *
-     * 입력: 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
-     * 출력: 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.
-     */
-    public static void main(String[] args) throws IOException {
-        // 입력은 InputStreamReader를 통해 '문자'를 'char'타입으로 byte단위로 받는다(InputStream 객체로)
-        // 받은 'char'타입 문자들을 BufferedReader를 통해 직렬화('String'타입으로 변환)한다.
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-        // 입력받은 문자열을 Intger 데이터타입으로 변환한다.(기본형 String)
-        int N = Integer.parseInt(br.readLine());
-
-        // 문자들을 입력받아 String을 만들 StringBuilder선언
-        // String은 불변의 객체이기 때문에 새로만들거나 합칠때마다
-        // 새로운 문자열을 참조하기에 비효율적이다.
-        StringBuilder sb = new StringBuilder();
-
-        // String을 delim(delimiter)으로 분리하여 토큰화합니다.
-        // delim으로는 기본적인 공백문자인 \t(가로탭), \n(줄바꿈), \r(캐리지 리턴) 등이 있습니다.
-        StringTokenizer st;
-
-        for(int i = 0; i < N; i++) {
-            // 공백 기준으로 토큰화(한번에 입력받음)
-            st = new StringTokenizer(br.readLine(), " ");
-
-            // String토큰들을 Intger로 형변환
-            int a = Integer.parseInt(st.nextToken());
-            int b = Integer.parseInt(st.nextToken());
-
-            // 정적메소드 gcd 실행결과인 최대공약수를 d변수에 입력
-            int d = gcd(a, b);
-
-            // 유클리드 호제법 사용
-            // 결과를 StringBuilder에 입력하고 줄바꿈을 붙인다.
-            sb.append(a * b / d).append('\n');
-        }
-        // 반복문 종료후 결과값들이 들어있는 sb출력
-        System.out.println(sb);
-
-    }
-
-    // 최대공약수 반복문 방식
-    public static int gcd(int a, int b) {
-
-        while (b != 0) {
-            int r = a % b; // 나머지를 구해준다.
-
-            // GCD(a, b) = GCD(b, r)이므로 변환한다.
-            a = b;
-            b = r;
-        }
-        return a;
-    }
-
-}
Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,47 +0,0 @@
-package bsjin1122.BOJ.week01;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-
-// 오큰수
-// data[] 에 값을 넣고 해당 인덱스의 값과 그 다음 data[i]번째 값보다 작으면(stack이 비어있지 않은 상태에서)
-// stack을 pop 한 인덱스의 값이 = data[i]가 된다.
-// false인 경우엔 stack에 i값 넣기
-public class BOJ_17298 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringBuffer sb = new StringBuffer();
-
-        int N = Integer.parseInt(br.readLine()); // 입력할 숫자의 수
-        int[] data = new int[N]; // 숫자 수만큼 배열 생성
-
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        for(int i =0; i<N; i++){
-            data[i] = Integer.parseInt(st.nextToken()); // 쪼개진 숫자만큼 배열에 넣기
-        }
-
-        Stack<Integer> stack = new Stack<>(); // 스택 할당
-
-        for(int i =0; i<N; i++){
-            while(!stack.isEmpty() && data[stack.peek()] < data[i]){
-                data[stack.pop()] = data[i];
-            }
-            stack.add(i);
-        }
-        while(!stack.isEmpty()) {
-            data[stack.pop()] = -1;
-        }
-        for(int i = 0; i < N; i++){
-            sb.append(data[i]).append(" ");
-        }
-
-        System.out.println(sb);
-
-    }
-
-}
Index: src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,37 +0,0 @@
-package bsjin1122.BOJ.week02;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-/**
- * @author bsjin
- * @date 2023/12/25
- * @note 백준 203-자료구조1 접미사 배열(11656)
- */
-
-/**
- * 문제: 접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.
- baekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.
- 문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.
- *
- */
-public class BOJ_11656 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        String str = br.readLine(); // 문자열 S입력
-        List<String> arrList = new ArrayList<>();
-
-        for(int i = 0; i < str.length(); i++){
-            arrList.add(str.substring(i)); // 문자열을 잘라서 arrayList에 넣는다.
-        }
-
-        Collections.sort(arrList); // 알파벳 순으로 정렬
-
-        for(String string : arrList){ // 출력
-            System.out.println(string);
-        }
-    }
-}
Index: src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,40 +0,0 @@
-package bsjin1122.BOJ.week02;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-/** @author bsjin
- * @date 2023/12/25
- * @title 백준 10430 나머지
- *
- * 문제
- * (A + B)%C는 ((A%C) + (B%C))%C 와 같을까?
- * (A×B)%C는 ((A%C) × (B%C))%C 와 같을까?
- * 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.
- * 첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.
- */
-
-public class BOJ_10430 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        String str = br.readLine(); // 문자열 S입력
-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
-        String[] strArray = str.split(" ");
-
-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
-        int[] intArray = new int[strArray.length];
-        for (int i = 0; i < strArray.length; i++) {
-            intArray[i] = Integer.parseInt(strArray[i]);
-        }
-
-        int a = intArray[0];
-        int b = intArray[1];
-        int c = intArray[2];
-
-        System.out.println((a+b)% c);
-        System.out.println(((a%c)+(b%c))%c);
-        System.out.println((a*b)%c);
-        System.out.println(((a%c)* (b%c))%c);
-    }
-}
Index: src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,46 +0,0 @@
-package bsjin1122.BOJ.week02;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-public class BOJ_2609 {
-    /**
-     * @author bsjin
-     * @date 2023/12/25
-     * @title 백준 2609 최대공약수와 최소공배수
-     *
-     * 문제
-     * 두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
-     * 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
-     */
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        String str = br.readLine(); // 문자열 S입력
-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
-        String[] strArray = str.split(" ");
-
-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
-        int[] intArray = new int[strArray.length];
-        for (int i = 0; i < strArray.length; i++) {
-            intArray[i] = Integer.parseInt(strArray[i]);
-        }
-
-        System.out.println(gcd(intArray[0], intArray[1]));
-        System.out.println(lcm(intArray[0], intArray[1]));
-
-
-    }
-    public static int gcd(int a, int b) { // 최대공약수
-        while (b != 0) {
-            int temp = b;
-            b = a % b;
-            a = temp;
-        }
-        return a;
-    }
- 
-    public static int lcm(int a, int b) { //최소공배수
-        return (a * b) / gcd(a, b);
-    }
-}
Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
===================================================================
diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
deleted file mode 100644
--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
@@ -1,45 +0,0 @@
-package bsjin1122.BOJ.week01;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Stack;
-import java.util.StringTokenizer;
-
-// 오등큰수
-public class BOJ_17299 {
-    static final int MAX = 1_000_001;
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        Stack<Integer> stack = new Stack<>();
-        int n = Integer.parseInt(br.readLine());
-        int count[] = new int[MAX];
-        int index[] = new int[n];
-        int ans[] = new int[n];
-
-        StringTokenizer st = new StringTokenizer(br.readLine());
-        for(int i = 0; i < n; i++){
-            index[i] = Integer.parseInt(st.nextToken());
-            count[index[i]]++;
-        }
-        for(int i = 0; i< n; i++){
-            while(!stack.isEmpty() && count[index[i]] > count[index[stack.peek()]]){
-                ans[stack.pop()] = index[i];
-            }
-            stack.push(i);
-        }
-
-        while(!stack.isEmpty()){
-            ans[stack.pop()] = -1;
-        }
-
-        StringBuilder sb = new StringBuilder();
-
-        for(int i = 0; i < n; i++){
-            sb.append(ans[i] + " ");
-        }
-        System.out.println(sb.toString());
-
-    }
-}
Index: src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
new file mode 100644
--- /dev/null	(date 1705332640015)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java	(date 1705332640015)
@@ -0,0 +1,50 @@
+package main.java.coderkim.BOJ.week04.week04_01.nagativeBinary_2089;
+
+import java.util.Scanner;
+
+/**
+ @Title -2진법(2089)
+ @Since 2024.01.13
+ @Content
+ 문제
+ -2진법은 부호 없는 2진수로 표현이 된다.
+ 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다.
+ 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.
+
+ 10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.
+
+ 입력
+ 첫 줄에 10진법으로 표현된 수 N이 주어진다.
+
+ 출력
+ -2진법 수를 출력한다.
+
+ */
+public class Main {
+    public static void main(String[] args) {
+
+        Scanner sc = new Scanner(System.in);
+
+        String input = sc.nextLine();
+        StringBuilder sb = new StringBuilder();
+        int n = Integer.parseInt(input);
+        if(n == 0){
+            sb.append(n);
+        }else{
+            // 마지막 몫이 1일 떄까지 반복
+            while(n != 1){
+                // 나머지는 반드시 양수여야 하기 때문에 절대값 반환
+                sb.append(Math.abs(n % (-2)));
+                n = (int) Math.ceil((double) n / (-2));
+            }
+
+            // 마지막 몫이 1일 때의 나머지도 추가 해줘야 함
+            sb.append(n);
+        }
+
+        // sb를 뒤집어서 출력
+        // -2진법 출력
+        System.out.println(sb.reverse());
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
new file mode 100644
--- /dev/null	(date 1705332640017)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java	(date 1705332640017)
@@ -0,0 +1,53 @@
+package main.java.coderkim.BOJ.week04.week04_01.octalToBinary_1212;
+
+import java.util.Scanner;
+
+
+/**
+ @Title 8진수 2진수(1212)
+ @Since 2024.01.12
+ @Content
+
+ 문제
+ 8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 8진수가 주어진다. 주어지는 수의 길이는 333,334을 넘지 않는다.
+
+ 출력
+ 첫째 줄에 주어진 수를 2진수로 변환하여 출력한다. 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다.
+ */
+public class Main {
+    public static void main(String[] args) {
+
+        Scanner sc = new Scanner(System.in);
+        String input = sc.nextLine();
+        int length = input.length();
+        StringBuilder sb = new StringBuilder();
+        String[] inputs = input.split("");
+            // 8진수를 2진수로 바꿔준다
+        for (int i = 0; i < length; i++) {
+            int octalValue = Integer.parseInt(inputs[i]);
+            String binaryValue = Integer.toBinaryString(octalValue);
+
+            // 2진수 자리 3자리로 맞춰준다
+            if(binaryValue.length() == 2 && i != 0)
+                binaryValue = "0" + binaryValue;
+            else if(binaryValue.length() == 1 && i !=0)
+                binaryValue = "00" + binaryValue;
+
+            // 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다
+            // 첫 번째 자리수가 0이면 뺴준다
+            if(!binaryValue.equals("0")){
+                if( i == 0 && binaryValue.startsWith("0") && binaryValue.startsWith("00")){
+                    binaryValue = binaryValue.substring(1,binaryValue.length());
+                }
+
+            }
+            sb.append(binaryValue);
+        }
+        String result = sb.toString();
+        System.out.println(result);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
new file mode 100644
--- /dev/null	(date 1705332640020)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java	(date 1705332640020)
@@ -0,0 +1,46 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion1_2745;
+
+import java.util.Scanner;
+
+/**
+ @Title 진법변환(2745)
+ @Since 2024.01.15
+ @Content
+ 문제
+ B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
+
+ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
+
+ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
+
+ 입력
+ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
+
+ B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.
+
+ 출력
+ 첫째 줄에 B진법 수 N을 10진법으로 출력한다.
+
+ */
+
+// 내장메소드를 이용한 방법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        // B진법 수 N이 주어진다.
+        // 입력 : 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
+        // N , B를 입력
+        String input = sc.nextLine();
+        String[] inputs = input.split(" ");
+
+        String N = inputs[0];
+        int B = Integer.parseInt(inputs[1]);
+
+        int decimalValue = Integer.parseInt(N,B);
+
+        System.out.println(decimalValue);
+        sc.close();
+
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
new file mode 100644
--- /dev/null	(date 1705332640026)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java	(date 1705332640026)
@@ -0,0 +1,39 @@
+package main.java.coderkim.BOJ.week05.week05_01.factorization_11653;
+import java.util.Scanner;
+/**
+ @Title 소인수분해(11653)
+ @Since 2024.01.15
+ @Content
+ 문제
+ 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
+
+ 출력
+ N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int N = sc.nextInt();
+
+        if (N == 1) {
+            // N이 1인 경우 아무것도 출력하지 않음
+        } else {
+            int divisor = 2; // 시작 소수로 2부터 시작
+            while (N > 1) {
+                if (N % divisor == 0) {
+                    // N이 현재의 divisor로 나누어떨어지면 소인수임
+                    System.out.println(divisor);
+                    N /= divisor;
+                } else {
+                    // 나누어떨어지지 않으면 다음 소수로 넘어감
+                    divisor++;
+                }
+            }
+        }
+
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
new file mode 100644
--- /dev/null	(date 1705332640012)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java	(date 1705332640012)
@@ -0,0 +1,70 @@
+package main.java.coderkim.BOJ.week04.week04_01.goldbachPartition_17103;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Scanner;
+
+/**
+ @Title 골드바흐 파티션(17103)
+ @Since 2024.01.13
+ @Content
+ 문제
+ 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다. (소수 : 1과 자신만 약수로 갖고 있는 수)
+ 짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때,골드바흐 파티션의 개수를 구해보자.
+ 두 소수의 순서만 다른 것은 같은 파티션이다.
+
+ 입력
+ 첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.
+
+ 출력
+ 각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.
+
+ */
+
+//TODO: 에라토스테네스 체와 관련된 문제 다시 풀기
+public class Main {
+    // 에라토스테네스의 체를 사용하여 소수를 구하는 함수
+    public static boolean[] sieveOfEratosthenes(int n) {
+        boolean[] isPrime = new boolean[n + 1];
+        for (int i = 2; i <= n; i++) {
+            isPrime[i] = true;
+        }
+        for (int i = 2; i * i <= n; i++) {
+            if (isPrime[i]) {
+                for (int j = i * i; j <= n; j += i) {
+                    isPrime[j] = false;
+                }
+            }
+        }
+        return isPrime;
+    }
+
+    // 골드바흐 파티션 개수를 구하는 함수
+    public static int goldbachPartitions(int n, boolean[] isPrime) {
+        int count = 0;
+        for (int i = 2; i <= n / 2; i++) {
+            if (isPrime[i] && isPrime[n - i]) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int T = sc.nextInt(); // 테스트 케이스의 개수
+
+        // 소수 판별을 위한 에라토스테네스의 체 적용
+        int maxN = 1000000; // 주어진 최대 N값
+        boolean[] isPrime = sieveOfEratosthenes(maxN);
+
+        for (int i = 0; i < T; i++) {
+            int N = sc.nextInt(); // 짝수 N
+            int partitions = goldbachPartitions(N, isPrime);
+            System.out.println(partitions);
+        }
+
+        sc.close();
+    }
+}
+
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
new file mode 100644
--- /dev/null	(date 1705332640024)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java	(date 1705332640024)
@@ -0,0 +1,71 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion3_11576;
+
+import java.util.Scanner;
+import java.util.Stack;
+
+/**
+ @Title Base Conversion(11576)
+ @Since 2024.01.15
+ @Content
+
+ 문제
+ 타임머신을 개발하는 정이는 오랜 노력 끝에 타임머신을 개발하는데 성공하였다.
+ 미래가 궁금한 정이는 자신이 개발한 타임머신을 이용하여 500년 후의 세계로 여행을 떠나게 되었다.
+ 500년 후의 세계에서도 프로그래밍을 하고 싶었던 정이는 백준 사이트에 접속하여 문제를 풀기로 하였다.
+ 그러나 미래세계는 A진법을 사용하고 있었고, B진법을 사용하던 정이는 문제를 풀 수가 없었다.
+ 뛰어난 프로그래머였던 정이는 A진법으로 나타낸 숫자를 B진법으로 변환시켜주는 프로그램을 작성하기로 하였다.
+
+ N진법이란, 한 자리에서 숫자를 표현할 때 쓸 수 있는 숫자의 가짓수가 N이라는 뜻이다.
+ 예를 들어 N이 17일 때 한 자릿수에서 사용할 수 있는 수는 0, 1, 2, ... , 16으로 총 17가지가 된다.
+
+ 입력
+ 입력의 첫 줄에는 미래세계에서 사용하는 진법 A와 정이가 사용하는 진법 B가 공백을 구분으로 주어진다. A와 B는 모두 2이상 30이하의 자연수다.
+
+ 입력의 두 번째 줄에는 A진법으로 나타낸 숫자의 자리수의 개수 m(1 ≤ m ≤ 25)이 주어진다.
+ 세 번째 줄에는 A진법을 이루고 있는 숫자 m개가 공백을 구분으로 높은 자릿수부터 차례대로 주어진다.
+ 각 숫자는 0이상 A미만임이 보장된다. 또한 수가 0으로 시작하는 경우는 존재하지 않는다.
+
+ A진법으로 나타낸 수를 10진법으로 변환하였을 때의 값은 양의 정수이며 220보다 작다.
+
+ 출력
+ 입력으로 주어진 A진법으로 나타낸 수를 B진법으로 변환하여 출력한다.
+ */
+//TODO: 다시 풀기
+public class Main {
+
+    static Stack<Integer> stack = new Stack<>();
+
+    static public void main(String args[]) {
+        Scanner sc = new Scanner(System.in);
+        int base_A = sc.nextInt();
+        int base_B = sc.nextInt();
+        int index = sc.nextInt();
+
+        int decimalNum = 0;
+
+        for(int i = index-1; i>=0; i--){
+            int x = sc.nextInt();
+            decimalNum += x * Math.pow(base_A, i);
+        }
+
+        convertBase(decimalNum, base_B);
+
+        int size = stack.size();
+        for(int i = 0; i<size; i++){
+            if(i == size-1)
+                System.out.print(stack.pop());
+            else
+                System.out.print(stack.pop() + " ");
+        }
+    }
+
+    static void convertBase(int decimalNum, int base) {
+        int num = decimalNum;
+
+        while (num != 0) {
+            int r = num % base;
+            num /= base;
+            stack.push(r);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
new file mode 100644
--- /dev/null	(date 1705332655585)
+++ b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java	(date 1705332655585)
@@ -0,0 +1,27 @@
+package main.java.coderkim.BOJ.week03.week03_02.hideAndSeek6_17087;
+
+/**
+ @Title 숨바꼭질6(17087)
+ @Since 2024.01.05
+ @Content
+ !!!!!!!!!!!이분탐색!!!!!!(다시 한 번 풀기)
+ 
+ 문제
+ 수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.
+
+ 수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.
+
+ 모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.
+
+ 입력
+ 첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.
+
+ 출력
+ 가능한 D값의 최댓값을 출력한다.
+
+ */
+public class Main {
+    public static void main(String[] args) {
+
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
new file mode 100644
--- /dev/null	(date 1705332640022)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java	(date 1705332640022)
@@ -0,0 +1,71 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion2_11005;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Scanner;
+
+/**
+ @Title 진법변환2(11005)
+ @Since 2024.01.15
+ @Content
+ 문제
+ 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.
+
+ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
+
+ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
+
+ 입력
+ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.
+
+ 출력
+ 첫째 줄에 10진법 수 N을 B진법으로 출력한다.
+ */
+
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        String input = sc.nextLine();
+        String[] inputs = input.split(" ");
+        int n = Integer.parseInt(inputs[0]);
+        int b = Integer.parseInt(inputs[1]);
+
+        List<Character> list = new ArrayList<>();
+        while (n > 0) {
+            if (n % b < 10) {
+                list.add((char) (n % b + '0'));
+            } else {
+                list.add((char) (n % b - 10 + 'A'));
+            }
+            n /= b;
+        }
+
+        for (int i = list.size() - 1; i >= 0; i--) {
+            System.out.print(list.get(i));
+        }
+        sc.close();
+    }
+}
+//TODO:
+// 내장메소드를 이용한 방법... 왜 오류 나지??
+    //public class Main{
+//    public static void main(String[] args) {
+//        Scanner sc = new Scanner(System.in);
+//
+//        String input = sc.nextLine();
+//        String[] inputs = input.split(" ");
+//
+//        // 10진법 숫자
+//        Integer N = Integer.parseInt(inputs[0]);
+//        // 변환할 진법 숫자
+//        int B = Integer.parseInt(inputs[1]);
+//
+//        String result = Integer.toString(N,B);
+//
+//        System.out.println(result);
+//
+//        sc.close();
+//
+//    }
+//}
Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
new file mode 100644
--- /dev/null	(date 1705332640029)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java	(date 1705332640029)
@@ -0,0 +1,39 @@
+package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN1_11726;
+
+import java.util.Scanner;
+
+/**
+ @Title 2 x N 타일링1(11726)
+ @Since 2024.01.14
+ @Content
+ 문제
+ 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.
+
+ 입력
+ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
+
+ 출력
+ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
+ */
+//TODO:동적계획법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int n = sc.nextInt();
+        int[] dp = new int[n + 1];
+        int mod = 10007;
+
+        dp[1] = 1;
+        if (n > 1) dp[2] = 2;
+
+        for (int i = 3; i <= n; i++) {
+            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
+        }
+
+        System.out.println(dp[n]);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
new file mode 100644
--- /dev/null	(date 1705332640033)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java	(date 1705332640033)
@@ -0,0 +1,37 @@
+package main.java.coderkim.BOJ.week05.week05_02.makeItOne_1463;
+
+import java.util.Scanner;
+
+/**
+  @Title 1로 만들기(1463)
+  @Since 2024.01.14
+  @Content 문제
+  정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
+  X가 3으로 나누어 떨어지면, 3으로 나눈다.
+  X가 2로 나누어 떨어지면, 2로 나눈다.
+  1을 뺀다.
+  정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
+  입력
+  첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
+  출력
+  첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
+ */
+
+//TODO: 동적 계획법 알고리즘
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int N = sc.nextInt();
+        int[] dp = new int[N + 1];
+
+        for (int i = 2; i <= N; i++) {
+            dp[i] = dp[i - 1] + 1;
+            if (i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
+            if (i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
+        }
+
+        System.out.println(dp[N]);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
new file mode 100644
--- /dev/null	(date 1705332640035)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java	(date 1705332640035)
@@ -0,0 +1,55 @@
+package main.java.coderkim.BOJ.week05.week05_02.oneTwoThreeSum_9095;
+
+import java.util.Scanner;
+
+/**
+ @Title
+ @Since
+ @Content
+ 문제
+ 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.
+
+ 1+1+1+1
+ 1+1+2
+ 1+2+1
+ 2+1+1
+ 2+2
+ 1+3
+ 3+1
+ 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
+
+ 출력
+ 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int T = sc.nextInt(); // 테스트 케이스의 개수
+
+        for (int t = 0; t < T; t++) {
+            int n = sc.nextInt(); // 정수 n
+
+            int[] dp = new int[n + 1];
+
+            dp[1] = 1;
+            if (n >= 2) {
+                dp[2] = 2;
+            }
+            if (n >= 3) {
+                dp[3] = 4;
+            }
+
+            for (int i = 4; i <= n; i++) {
+                dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
+            }
+
+            System.out.println(dp[n]);
+        }
+
+        sc.close();
+    }
+}
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
new file mode 100644
--- /dev/null	(date 1705332640031)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java	(date 1705332640031)
@@ -0,0 +1,41 @@
+package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN2_11727;
+
+import java.util.Scanner;
+
+/**
+ @Title 2 X N 타일링2(11727)
+ @Since 2024.01.14
+ @Content
+ 문제
+ 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 아래 그림은 2×17 직사각형을 채운 한가지 예이다.
+
+ 입력
+ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
+
+ 출력
+ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
+ */
+//TODO:동적계획법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int n = sc.nextInt();
+        int[] dp = new int[n + 1];
+        int mod = 10007;
+
+        dp[1] = 1;
+        if (n > 1) {
+            dp[2] = 3;
+        }
+
+        for (int i = 3; i <= n; i++) {
+            dp[i] = (dp[i - 1] + dp[i - 2] * 2) % mod;
+        }
+
+        System.out.println(dp[n]);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
new file mode 100644
--- /dev/null	(date 1705332640010)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java	(date 1705332640010)
@@ -0,0 +1,49 @@
+package main.java.coderkim.BOJ.week04.week04_01.binaryToOctal_1373;
+import java.util.Scanner;
+
+/**
+ @Title 2진수 8진수(1373)
+ @Since 2024.01.07
+ @Content 문제
+ 2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다.
+
+ 출력
+ 첫째 줄에 주어진 수를 8진수로 변환하여 출력한다.
+
+ 참고 <a href="https://m.blog.naver.com/javrin4/220956809081">...</a>
+
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        // 입력
+        // 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다
+        String input = sc.nextLine();
+        int length = input.length();
+        // 8진수를 담기 위한 객체
+        StringBuilder octalStringBuilder = new StringBuilder();
+        // 8진수는 2의 3제곱. 뒤에서부터 숫자를 3자리씩 묶어준 그룹을 2진수 8진수 로 변환.
+        // 모자른 자리는 0을 플러스 해준다
+        for (int i = length; i > 0; i -= 3) {
+            String group = input.substring(Math.max(i - 3, 0),i);
+            if(group.length() < 3){
+                group = "0" + group;
+            }
+            int decimal = Integer.parseInt(group, 2);
+            octalStringBuilder.append(decimal);
+        }
+
+        // 저장된 순서가 거꾸로이기 때문에 뒤집어준다.
+        String octal = octalStringBuilder.reverse().toString();
+
+        System.out.println(octal);
+
+        sc.close();
+
+
+    }
+}
