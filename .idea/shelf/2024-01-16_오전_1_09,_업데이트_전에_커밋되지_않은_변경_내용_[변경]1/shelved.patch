Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
new file mode 100644
--- /dev/null	(date 1705334770448)
+++ b/.idea/workspace.xml	(date 1705334770448)
@@ -0,0 +1,296 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="09e90688-26ca-40d8-b6d7-0a5829d578b0" name="변경" comment=".gitignore 및 pom.xml 제거" />
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="FileTemplateManagerImpl">
+    <option name="RECENT_TEMPLATES">
+      <list>
+        <option value="Class" />
+      </list>
+    </option>
+  </component>
+  <component name="Git.Settings">
+    <option name="PREVIOUS_COMMIT_AUTHORS">
+      <list>
+        <option value="GoLuckyP &lt;goluckyp@gmail.com&gt;" />
+      </list>
+    </option>
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$" value="master" />
+      </map>
+    </option>
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+    <option name="RESET_MODE" value="MIXED" />
+  </component>
+  <component name="GitHubPullRequestSearchHistory">{
+  &quot;lastFilter&quot;: {
+    &quot;state&quot;: &quot;OPEN&quot;
+  }
+}</component>
+  <component name="GithubPullRequestsUISettings">
+    <option name="selectedUrlAndAccountId">
+      <UrlAndAccount>
+        <option name="accountId" value="455d12a4-e081-47e8-a2fd-02f1f85b172e" />
+        <option name="url" value="https://github.com/bsjin1122/start_coding_study.git" />
+      </UrlAndAccount>
+    </option>
+  </component>
+  <component name="MarkdownSettingsMigration">
+    <option name="stateVersion" value="1" />
+  </component>
+  <component name="ProjectId" id="2ZUSoASZA1fEiuJhzWOZVPEYd6h" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
+    <ConfirmationsSetting value="2" id="Add" />
+  </component>
+  <component name="ProjectViewState">
+    <option name="abbreviatePackageNames" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "SHARE_PROJECT_CONFIGURATION_FILES": "true",
+    "git-widget-placeholder": "main",
+    "last_opened_file_path": "C:/Users/SEOJIN/SJ_STUDY/CodingTest",
+    "project.structure.last.edited": "모듈",
+    "project.structure.proportion": "0.15",
+    "project.structure.side.proportion": "0.2"
+  }
+}]]></component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="애플리케이션 수준" UseSingleDictionary="true" transferred="true" />
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="디폴트 작업">
+      <changelist id="09e90688-26ca-40d8-b6d7-0a5829d578b0" name="변경" comment="" />
+      <created>1702475338220</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1702475338220</updated>
+    </task>
+    <task id="LOCAL-00001" summary="test2">
+      <created>1702475497610</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1702475497610</updated>
+    </task>
+    <task id="LOCAL-00002" summary="test2">
+      <created>1702475807378</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1702475807378</updated>
+    </task>
+    <task id="LOCAL-00003" summary="test3">
+      <created>1702475885418</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1702475885418</updated>
+    </task>
+    <task id="LOCAL-00004" summary="directory 수정 (BOJ/week01)">
+      <created>1702476271811</created>
+      <option name="number" value="00004" />
+      <option name="presentableId" value="LOCAL-00004" />
+      <option name="project" value="LOCAL" />
+      <updated>1702476271811</updated>
+    </task>
+    <task id="LOCAL-00005" summary="directory 수정 (BOJ/week01)">
+      <created>1702476302602</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1702476302602</updated>
+    </task>
+    <task id="LOCAL-00006" summary="directory 수정 (231218)">
+      <created>1702900035490</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1702900035490</updated>
+    </task>
+    <task id="LOCAL-00007" summary="extentions, maven 설정파일 제거 (231218)">
+      <created>1702900443166</created>
+      <option name="number" value="00007" />
+      <option name="presentableId" value="LOCAL-00007" />
+      <option name="project" value="LOCAL" />
+      <updated>1702900443167</updated>
+    </task>
+    <task id="LOCAL-00008" summary="무지님 package명 변경">
+      <created>1702903093106</created>
+      <option name="number" value="00008" />
+      <option name="presentableId" value="LOCAL-00008" />
+      <option name="project" value="LOCAL" />
+      <updated>1702903093106</updated>
+    </task>
+    <task id="LOCAL-00009" summary="무지님 package명 변경">
+      <created>1702903147934</created>
+      <option name="number" value="00009" />
+      <option name="presentableId" value="LOCAL-00009" />
+      <option name="project" value="LOCAL" />
+      <updated>1702903147934</updated>
+    </task>
+    <task id="LOCAL-00010" summary="ss">
+      <created>1702903282148</created>
+      <option name="number" value="00010" />
+      <option name="presentableId" value="LOCAL-00010" />
+      <option name="project" value="LOCAL" />
+      <updated>1702903282148</updated>
+    </task>
+    <task id="LOCAL-00011" summary="ss">
+      <created>1702903721348</created>
+      <option name="number" value="00011" />
+      <option name="presentableId" value="LOCAL-00011" />
+      <option name="project" value="LOCAL" />
+      <updated>1702903721348</updated>
+    </task>
+    <task id="LOCAL-00012" summary="[12월-week01] 단어뒤집기2, 쇠막대기, 오큰수, 오등큰수">
+      <created>1703000170736</created>
+      <option name="number" value="00012" />
+      <option name="presentableId" value="LOCAL-00012" />
+      <option name="project" value="LOCAL" />
+      <updated>1703000170736</updated>
+    </task>
+    <task id="LOCAL-00013" summary="[12월-week01] 단어뒤집기2, 쇠막대기, 오큰수, 오등큰수">
+      <created>1703000894575</created>
+      <option name="number" value="00013" />
+      <option name="presentableId" value="LOCAL-00013" />
+      <option name="project" value="LOCAL" />
+      <updated>1703000894575</updated>
+    </task>
+    <task id="LOCAL-00014" summary="[12월-week02] 접미사배열(11656), 나머지(10430), 최대공약수최소공배수(2609), 최소공배수(1934)">
+      <created>1703515988047</created>
+      <option name="number" value="00014" />
+      <option name="presentableId" value="LOCAL-00014" />
+      <option name="project" value="LOCAL" />
+      <updated>1703515988047</updated>
+    </task>
+    <task id="LOCAL-00015" summary="[12월-week03] 소수 찾기(1978)">
+      <created>1703778852798</created>
+      <option name="number" value="00015" />
+      <option name="presentableId" value="LOCAL-00015" />
+      <option name="project" value="LOCAL" />
+      <updated>1703778852798</updated>
+    </task>
+    <task id="LOCAL-00016" summary="[12월-week03] 소수 찾기(1978), 소수 구하기(1979)">
+      <created>1703780571521</created>
+      <option name="number" value="00016" />
+      <option name="presentableId" value="LOCAL-00016" />
+      <option name="project" value="LOCAL" />
+      <updated>1703780571521</updated>
+    </task>
+    <task id="LOCAL-00017" summary="코더님 커밋 수정">
+      <created>1705333810207</created>
+      <option name="number" value="00017" />
+      <option name="presentableId" value="LOCAL-00017" />
+      <option name="project" value="LOCAL" />
+      <updated>1705333810207</updated>
+    </task>
+    <task id="LOCAL-00018" summary="Revert &quot;[BOJ] 12월 3주차&quot;&#10;&#10;(cherry picked from commit 83e2a4a8aa9ce52b3d6ee8c4513352d5d9b3c5c3)">
+      <created>1705334183432</created>
+      <option name="number" value="00018" />
+      <option name="presentableId" value="LOCAL-00018" />
+      <option name="project" value="LOCAL" />
+      <updated>1705334183432</updated>
+    </task>
+    <task id="LOCAL-00019" summary="코더님 week03_02 반영">
+      <created>1705334317123</created>
+      <option name="number" value="00019" />
+      <option name="presentableId" value="LOCAL-00019" />
+      <option name="project" value="LOCAL" />
+      <updated>1705334317123</updated>
+    </task>
+    <task id="LOCAL-00020" summary="코더님 week03_02 반영">
+      <created>1705334348378</created>
+      <option name="number" value="00020" />
+      <option name="presentableId" value="LOCAL-00020" />
+      <option name="project" value="LOCAL" />
+      <updated>1705334348378</updated>
+    </task>
+    <task id="LOCAL-00021" summary=".gitignore 및 pom.xml 제거">
+      <created>1705334760977</created>
+      <option name="number" value="00021" />
+      <option name="presentableId" value="LOCAL-00021" />
+      <option name="project" value="LOCAL" />
+      <updated>1705334760977</updated>
+    </task>
+    <option name="localTasksCounter" value="22" />
+    <servers />
+  </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="RECENT_FILTERS">
+      <map>
+        <entry key="Branch">
+          <value>
+            <list>
+              <RecentGroup>
+                <option name="FILTER_VALUES">
+                  <option value="main" />
+                </option>
+              </RecentGroup>
+            </list>
+          </value>
+        </entry>
+        <entry key="User">
+          <value>
+            <list>
+              <RecentGroup>
+                <option name="FILTER_VALUES">
+                  <option value="*" />
+                </option>
+              </RecentGroup>
+            </list>
+          </value>
+        </entry>
+      </map>
+    </option>
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State>
+              <option name="FILTERS">
+                <map>
+                  <entry key="branch">
+                    <value>
+                      <list>
+                        <option value="main" />
+                      </list>
+                    </value>
+                  </entry>
+                </map>
+              </option>
+            </State>
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="test2" />
+    <MESSAGE value="test3" />
+    <MESSAGE value="directory 수정 (BOJ/week01)" />
+    <MESSAGE value="directory 수정 (231218)" />
+    <MESSAGE value="extentions, maven 설정파일 제거 (231218)" />
+    <MESSAGE value="무지님 package명 변경" />
+    <MESSAGE value="ss" />
+    <MESSAGE value="[12월-week01] 단어뒤집기2, 쇠막대기, 오큰수, 오등큰수" />
+    <MESSAGE value="[12월-week02] 접미사배열(11656), 나머지(10430), 최대공약수최소공배수(2609), 최소공배수(1934)" />
+    <MESSAGE value="[12월-week03] 소수 찾기(1978)" />
+    <MESSAGE value="[12월-week03] 소수 찾기(1978), 소수 구하기(1979)" />
+    <MESSAGE value="merge 체리픽 &#10;[BOJ] ~1월 2주차까지&#10;2진수8진수(1373) / 골드바흐파티션(17103) / -2진수(2089) / 8진수2진수(1212) / 진법변환(2745) / 진법변환2(11005) / Base Conversion(11576) / 소인수분해(11653) /1로 만들기(1463)  / 2 x N 타일링1(11726) / 2 X N 타일링2(11727) / 1,2,3 더하기(9095)" />
+    <MESSAGE value="코더님 커밋 수정" />
+    <MESSAGE value="Revert &quot;[BOJ] 12월 3주차&quot;&#10;&#10;(cherry picked from commit 83e2a4a8aa9ce52b3d6ee8c4513352d5d9b3c5c3)" />
+    <MESSAGE value="코더님 week03_02 반영" />
+    <MESSAGE value=".gitignore 및 pom.xml 제거" />
+    <option name="LAST_COMMIT_MESSAGE" value=".gitignore 및 pom.xml 제거" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
--- /dev/null	(date 1705333521387)
+++ b/.idea/compiler.xml	(date 1705333521387)
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <annotationProcessing>
+      <profile name="Maven default annotation processors profile" enabled="true">
+        <sourceOutputDir name="target/generated-sources/annotations" />
+        <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
+        <outputRelativeToContentRoot value="true" />
+      </profile>
+    </annotationProcessing>
+    <bytecodeTargetLevel>
+      <module name="CodingTest" target="17" />
+    </bytecodeTargetLevel>
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
new file mode 100644
--- /dev/null	(date 1705334691623)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java	(date 1705334691623)
@@ -0,0 +1,55 @@
+package main.java.coderkim.BOJ.week05.week05_02.oneTwoThreeSum_9095;
+
+import java.util.Scanner;
+
+/**
+ @Title
+ @Since
+ @Content
+ 문제
+ 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.
+
+ 1+1+1+1
+ 1+1+2
+ 1+2+1
+ 2+1+1
+ 2+2
+ 1+3
+ 3+1
+ 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
+
+ 출력
+ 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int T = sc.nextInt(); // 테스트 케이스의 개수
+
+        for (int t = 0; t < T; t++) {
+            int n = sc.nextInt(); // 정수 n
+
+            int[] dp = new int[n + 1];
+
+            dp[1] = 1;
+            if (n >= 2) {
+                dp[2] = 2;
+            }
+            if (n >= 3) {
+                dp[3] = 4;
+            }
+
+            for (int i = 4; i <= n; i++) {
+                dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
+            }
+
+            System.out.println(dp[n]);
+        }
+
+        sc.close();
+    }
+}
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
new file mode 100644
--- /dev/null	(date 1705334691617)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java	(date 1705334691617)
@@ -0,0 +1,39 @@
+package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN1_11726;
+
+import java.util.Scanner;
+
+/**
+ @Title 2 x N 타일링1(11726)
+ @Since 2024.01.14
+ @Content
+ 문제
+ 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.
+
+ 입력
+ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
+
+ 출력
+ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
+ */
+//TODO:동적계획법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int n = sc.nextInt();
+        int[] dp = new int[n + 1];
+        int mod = 10007;
+
+        dp[1] = 1;
+        if (n > 1) dp[2] = 2;
+
+        for (int i = 3; i <= n; i++) {
+            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
+        }
+
+        System.out.println(dp[n]);
+        sc.close();
+    }
+}
Index: .idea/jarRepositories.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/jarRepositories.xml b/.idea/jarRepositories.xml
new file mode 100644
--- /dev/null	(date 1702904196784)
+++ b/.idea/jarRepositories.xml	(date 1702904196784)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RemoteRepositoriesConfiguration">
+    <remote-repository>
+      <option name="id" value="central" />
+      <option name="name" value="Central Repository" />
+      <option name="url" value="https://repo.maven.apache.org/maven2" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="central" />
+      <option name="name" value="Maven Central repository" />
+      <option name="url" value="https://repo1.maven.org/maven2" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="jboss.community" />
+      <option name="name" value="JBoss Community repository" />
+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
+    </remote-repository>
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
new file mode 100644
--- /dev/null	(date 1705334691619)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java	(date 1705334691619)
@@ -0,0 +1,41 @@
+package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN2_11727;
+
+import java.util.Scanner;
+
+/**
+ @Title 2 X N 타일링2(11727)
+ @Since 2024.01.14
+ @Content
+ 문제
+ 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
+
+ 아래 그림은 2×17 직사각형을 채운 한가지 예이다.
+
+ 입력
+ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
+
+ 출력
+ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
+ */
+//TODO:동적계획법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int n = sc.nextInt();
+        int[] dp = new int[n + 1];
+        int mod = 10007;
+
+        dp[1] = 1;
+        if (n > 1) {
+            dp[2] = 3;
+        }
+
+        for (int i = 3; i <= n; i++) {
+            dp[i] = (dp[i - 1] + dp[i - 2] * 2) % mod;
+        }
+
+        System.out.println(dp[n]);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
new file mode 100644
--- /dev/null	(date 1705334691612)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java	(date 1705334691612)
@@ -0,0 +1,71 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion3_11576;
+
+import java.util.Scanner;
+import java.util.Stack;
+
+/**
+ @Title Base Conversion(11576)
+ @Since 2024.01.15
+ @Content
+
+ 문제
+ 타임머신을 개발하는 정이는 오랜 노력 끝에 타임머신을 개발하는데 성공하였다.
+ 미래가 궁금한 정이는 자신이 개발한 타임머신을 이용하여 500년 후의 세계로 여행을 떠나게 되었다.
+ 500년 후의 세계에서도 프로그래밍을 하고 싶었던 정이는 백준 사이트에 접속하여 문제를 풀기로 하였다.
+ 그러나 미래세계는 A진법을 사용하고 있었고, B진법을 사용하던 정이는 문제를 풀 수가 없었다.
+ 뛰어난 프로그래머였던 정이는 A진법으로 나타낸 숫자를 B진법으로 변환시켜주는 프로그램을 작성하기로 하였다.
+
+ N진법이란, 한 자리에서 숫자를 표현할 때 쓸 수 있는 숫자의 가짓수가 N이라는 뜻이다.
+ 예를 들어 N이 17일 때 한 자릿수에서 사용할 수 있는 수는 0, 1, 2, ... , 16으로 총 17가지가 된다.
+
+ 입력
+ 입력의 첫 줄에는 미래세계에서 사용하는 진법 A와 정이가 사용하는 진법 B가 공백을 구분으로 주어진다. A와 B는 모두 2이상 30이하의 자연수다.
+
+ 입력의 두 번째 줄에는 A진법으로 나타낸 숫자의 자리수의 개수 m(1 ≤ m ≤ 25)이 주어진다.
+ 세 번째 줄에는 A진법을 이루고 있는 숫자 m개가 공백을 구분으로 높은 자릿수부터 차례대로 주어진다.
+ 각 숫자는 0이상 A미만임이 보장된다. 또한 수가 0으로 시작하는 경우는 존재하지 않는다.
+
+ A진법으로 나타낸 수를 10진법으로 변환하였을 때의 값은 양의 정수이며 220보다 작다.
+
+ 출력
+ 입력으로 주어진 A진법으로 나타낸 수를 B진법으로 변환하여 출력한다.
+ */
+//TODO: 다시 풀기
+public class Main {
+
+    static Stack<Integer> stack = new Stack<>();
+
+    static public void main(String args[]) {
+        Scanner sc = new Scanner(System.in);
+        int base_A = sc.nextInt();
+        int base_B = sc.nextInt();
+        int index = sc.nextInt();
+
+        int decimalNum = 0;
+
+        for(int i = index-1; i>=0; i--){
+            int x = sc.nextInt();
+            decimalNum += x * Math.pow(base_A, i);
+        }
+
+        convertBase(decimalNum, base_B);
+
+        int size = stack.size();
+        for(int i = 0; i<size; i++){
+            if(i == size-1)
+                System.out.print(stack.pop());
+            else
+                System.out.print(stack.pop() + " ");
+        }
+    }
+
+    static void convertBase(int decimalNum, int base) {
+        int num = decimalNum;
+
+        while (num != 0) {
+            int r = num % base;
+            num /= base;
+            stack.push(r);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
new file mode 100644
--- /dev/null	(date 1705334691621)
+++ b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java	(date 1705334691621)
@@ -0,0 +1,37 @@
+package main.java.coderkim.BOJ.week05.week05_02.makeItOne_1463;
+
+import java.util.Scanner;
+
+/**
+  @Title 1로 만들기(1463)
+  @Since 2024.01.14
+  @Content 문제
+  정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
+  X가 3으로 나누어 떨어지면, 3으로 나눈다.
+  X가 2로 나누어 떨어지면, 2로 나눈다.
+  1을 뺀다.
+  정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
+  입력
+  첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
+  출력
+  첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
+ */
+
+//TODO: 동적 계획법 알고리즘
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        int N = sc.nextInt();
+        int[] dp = new int[N + 1];
+
+        for (int i = 2; i <= N; i++) {
+            dp[i] = dp[i - 1] + 1;
+            if (i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
+            if (i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
+        }
+
+        System.out.println(dp[N]);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
new file mode 100644
--- /dev/null	(date 1705334691607)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java	(date 1705334691607)
@@ -0,0 +1,46 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion1_2745;
+
+import java.util.Scanner;
+
+/**
+ @Title 진법변환(2745)
+ @Since 2024.01.15
+ @Content
+ 문제
+ B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
+
+ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
+
+ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
+
+ 입력
+ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
+
+ B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.
+
+ 출력
+ 첫째 줄에 B진법 수 N을 10진법으로 출력한다.
+
+ */
+
+// 내장메소드를 이용한 방법
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        // B진법 수 N이 주어진다.
+        // 입력 : 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
+        // N , B를 입력
+        String input = sc.nextLine();
+        String[] inputs = input.split(" ");
+
+        String N = inputs[0];
+        int B = Integer.parseInt(inputs[1]);
+
+        int decimalValue = Integer.parseInt(N,B);
+
+        System.out.println(decimalValue);
+        sc.close();
+
+    }
+}
Index: .idea/shelf/2024-01-16_오전_1_09,_업데이트_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/shelf/2024-01-16_오전_1_09,_업데이트_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch b/.idea/shelf/2024-01-16_오전_1_09,_업데이트_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch
new file mode 100644
--- /dev/null	(date 1705334956867)
+++ b/.idea/shelf/2024-01-16_오전_1_09,_업데이트_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch	(date 1705334956867)
@@ -0,0 +1,722 @@
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,35 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.util.Scanner;
+-import java.util.Stack;
+-
+-// 쇠막대기
+-public class BOJ_10799 {
+-    public static void main(String[] args) {
+-        Scanner sc = new Scanner(System.in);
+-
+-        String input = sc.next();
+-
+-        int result = 0;
+-
+-        Stack<Character> stack = new Stack<>();
+-
+-        for(int i =0; i<input.length(); i++){
+-            if(input.charAt(i) == '('){
+-                stack.push('(');
+-            }else if(input.charAt(i)==')'){
+-                stack.pop();
+-            }
+-
+-            if(i >0){
+-                if(input.charAt(i-1) == '(' && input.charAt(i) ==')'){
+-                    result += stack.size();
+-                }else if(input.charAt(i-1) == ')' && input.charAt(i) == ')'){
+-                    result++;
+-                }
+-            }
+-        }
+-        System.out.println(result);
+-    }
+-}
+-
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,57 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.Stack;
+-
+-// 단어뒤집기2
+-public class BOJ_17413 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-
+-
+-        String str = br.readLine(); // 문자열 S입력
+-        StringBuilder sb = new StringBuilder(); // 결과 값을 출력할 StringBuilder
+-        Stack<Character> stack = new Stack <> (); // 후입선출 기능을 이용하기 위한 자료구조 Stack
+-        boolean flag = false;
+-
+-        for(int i =0; i < str.length(); i++){
+-            if(str.charAt(i) == '<'){
+-                while(!stack.isEmpty()){
+-                    sb.append(stack.pop());
+-                }
+-                flag = true;
+-            }
+-            else if(str.charAt(i) == '>'){
+-                flag = false;
+-                sb.append(str.charAt(i));
+-                continue;
+-            }
+-
+-            if(flag == true){
+-                sb.append(str.charAt(i));
+-            }else if(flag == false) {
+-                if (str.charAt(i) == ' ') {
+-                    while (!stack.isEmpty()) {
+-                        sb.append(stack.pop());
+-                    }
+-                    sb.append(' ');
+-                    continue;
+-                } else {
+-                    stack.push(str.charAt(i));
+-                }
+-            }
+-
+-            if(i == str.length() - 1){
+-                while (!stack.isEmpty()) {
+-                    sb.append(stack.pop());
+-                }
+-            }
+-        }
+-        // 결과문 출력
+-        System.out.println(sb);
+-
+-
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,46 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-
+-public class BOJ_2609 {
+-    /**
+-     * @author bsjin
+-     * @date 2023/12/25
+-     * @title 백준 2609 최대공약수와 최소공배수
+-     *
+-     * 문제
+-     * 두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
+-     * 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
+-     */
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
+-        String[] strArray = str.split(" ");
+-
+-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
+-        int[] intArray = new int[strArray.length];
+-        for (int i = 0; i < strArray.length; i++) {
+-            intArray[i] = Integer.parseInt(strArray[i]);
+-        }
+-
+-        System.out.println(gcd(intArray[0], intArray[1]));
+-        System.out.println(lcm(intArray[0], intArray[1]));
+-
+-
+-    }
+-    public static int gcd(int a, int b) { // 최대공약수
+-        while (b != 0) {
+-            int temp = b;
+-            b = a % b;
+-            a = temp;
+-        }
+-        return a;
+-    }
+- 
+-    public static int lcm(int a, int b) { //최소공배수
+-        return (a * b) / gcd(a, b);
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,74 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.ArrayList;
+-import java.util.Scanner;
+-import java.util.StringTokenizer;
+-
+-public class BOJ_1934 {
+-    /**
+-     * @author bsjin
+-     * @date 2023/12/25
+-     * @title 백준 1934 최소공배수
+-     *
+-     * 문제
+-     * 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다.
+-     * 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
+-     * 두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
+-     *
+-     * 입력: 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
+-     * 출력: 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.
+-     */
+-    public static void main(String[] args) throws IOException {
+-        // 입력은 InputStreamReader를 통해 '문자'를 'char'타입으로 byte단위로 받는다(InputStream 객체로)
+-        // 받은 'char'타입 문자들을 BufferedReader를 통해 직렬화('String'타입으로 변환)한다.
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-
+-        // 입력받은 문자열을 Intger 데이터타입으로 변환한다.(기본형 String)
+-        int N = Integer.parseInt(br.readLine());
+-
+-        // 문자들을 입력받아 String을 만들 StringBuilder선언
+-        // String은 불변의 객체이기 때문에 새로만들거나 합칠때마다
+-        // 새로운 문자열을 참조하기에 비효율적이다.
+-        StringBuilder sb = new StringBuilder();
+-
+-        // String을 delim(delimiter)으로 분리하여 토큰화합니다.
+-        // delim으로는 기본적인 공백문자인 \t(가로탭), \n(줄바꿈), \r(캐리지 리턴) 등이 있습니다.
+-        StringTokenizer st;
+-
+-        for(int i = 0; i < N; i++) {
+-            // 공백 기준으로 토큰화(한번에 입력받음)
+-            st = new StringTokenizer(br.readLine(), " ");
+-
+-            // String토큰들을 Intger로 형변환
+-            int a = Integer.parseInt(st.nextToken());
+-            int b = Integer.parseInt(st.nextToken());
+-
+-            // 정적메소드 gcd 실행결과인 최대공약수를 d변수에 입력
+-            int d = gcd(a, b);
+-
+-            // 유클리드 호제법 사용
+-            // 결과를 StringBuilder에 입력하고 줄바꿈을 붙인다.
+-            sb.append(a * b / d).append('\n');
+-        }
+-        // 반복문 종료후 결과값들이 들어있는 sb출력
+-        System.out.println(sb);
+-
+-    }
+-
+-    // 최대공약수 반복문 방식
+-    public static int gcd(int a, int b) {
+-
+-        while (b != 0) {
+-            int r = a % b; // 나머지를 구해준다.
+-
+-            // GCD(a, b) = GCD(b, r)이므로 변환한다.
+-            a = b;
+-            b = r;
+-        }
+-        return a;
+-    }
+-
+-}
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,45 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.Stack;
+-import java.util.StringTokenizer;
+-
+-// 오등큰수
+-public class BOJ_17299 {
+-    static final int MAX = 1_000_001;
+-
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        Stack<Integer> stack = new Stack<>();
+-        int n = Integer.parseInt(br.readLine());
+-        int count[] = new int[MAX];
+-        int index[] = new int[n];
+-        int ans[] = new int[n];
+-
+-        StringTokenizer st = new StringTokenizer(br.readLine());
+-        for(int i = 0; i < n; i++){
+-            index[i] = Integer.parseInt(st.nextToken());
+-            count[index[i]]++;
+-        }
+-        for(int i = 0; i< n; i++){
+-            while(!stack.isEmpty() && count[index[i]] > count[index[stack.peek()]]){
+-                ans[stack.pop()] = index[i];
+-            }
+-            stack.push(i);
+-        }
+-
+-        while(!stack.isEmpty()){
+-            ans[stack.pop()] = -1;
+-        }
+-
+-        StringBuilder sb = new StringBuilder();
+-
+-        for(int i = 0; i < n; i++){
+-            sb.append(ans[i] + " ");
+-        }
+-        System.out.println(sb.toString());
+-
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,47 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.*;
+-import java.util.stream.Collectors;
+-import java.util.stream.IntStream;
+-
+-// 오큰수
+-// data[] 에 값을 넣고 해당 인덱스의 값과 그 다음 data[i]번째 값보다 작으면(stack이 비어있지 않은 상태에서)
+-// stack을 pop 한 인덱스의 값이 = data[i]가 된다.
+-// false인 경우엔 stack에 i값 넣기
+-public class BOJ_17298 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        StringBuffer sb = new StringBuffer();
+-
+-        int N = Integer.parseInt(br.readLine()); // 입력할 숫자의 수
+-        int[] data = new int[N]; // 숫자 수만큼 배열 생성
+-
+-        StringTokenizer st = new StringTokenizer(br.readLine());
+-
+-        for(int i =0; i<N; i++){
+-            data[i] = Integer.parseInt(st.nextToken()); // 쪼개진 숫자만큼 배열에 넣기
+-        }
+-
+-        Stack<Integer> stack = new Stack<>(); // 스택 할당
+-
+-        for(int i =0; i<N; i++){
+-            while(!stack.isEmpty() && data[stack.peek()] < data[i]){
+-                data[stack.pop()] = data[i];
+-            }
+-            stack.add(i);
+-        }
+-        while(!stack.isEmpty()) {
+-            data[stack.pop()] = -1;
+-        }
+-        for(int i = 0; i < N; i++){
+-            sb.append(data[i]).append(" ");
+-        }
+-
+-        System.out.println(sb);
+-
+-    }
+-
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,37 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.ArrayList;
+-import java.util.Collections;
+-import java.util.List;
+-/**
+- * @author bsjin
+- * @date 2023/12/25
+- * @note 백준 203-자료구조1 접미사 배열(11656)
+- */
+-
+-/**
+- * 문제: 접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.
+- baekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.
+- 문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.
+- *
+- */
+-public class BOJ_11656 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        List<String> arrList = new ArrayList<>();
+-
+-        for(int i = 0; i < str.length(); i++){
+-            arrList.add(str.substring(i)); // 문자열을 잘라서 arrayList에 넣는다.
+-        }
+-
+-        Collections.sort(arrList); // 알파벳 순으로 정렬
+-
+-        for(String string : arrList){ // 출력
+-            System.out.println(string);
+-        }
+-    }
+-}
+Index: src/main/java/coderkim/BOJ/week03/week03_02/zeroCountInCombination_2004/Main.java
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountInCombination_2004/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountInCombination_2004/Main.java
+deleted file mode 100644
+--- a/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountInCombination_2004/Main.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,81 +0,0 @@
+-package main.java.coderkim.BOJ.week03.week03_02.zeroCountInCombination_2004;
+-
+-import java.util.Scanner;
+-
+-/**
+-  @Title 조합 0의 개수(2004)
+-  @Since 2024.01.03
+-  @Content
+-  문제
+-  (n
+-  m)의 끝자리 0의 개수를 출력하는 프로그램을 작성하시오.
+-
+-  입력
+-  첫째 줄에 정수 n,m (0 ≤  m ≤ n ≤ 2,000,000,000, n ≠ 0) 이 들어온다
+-
+-  출력
+-  첫째 줄에
+-  (n
+-  m)의 끝자리 0의 개수를 출력한다.
+- */
+-// 1번 코드
+-public class Main {
+-
+-    public static void main(String[] args) throws Exception {
+-        /** 조합 공식:
+-
+-         (n    =   n!/ m!(n−m)!
+-         m)                    */
+-        Scanner sc = new Scanner(System.in);
+-        int n = sc.nextInt();
+-        int m = sc.nextInt();
+-
+-        // 0은 2 * 5로 생겨남
+-        // 조합은 nCm을 계산할 때, n!을 m!과 (n-m)!로 나누면서 중복되는 2와 5의 인수를 제거하기 때문에
+-        // 2와 5를 둘 다 고려 해야 함
+-        // 더 적은 경우가 0의 개수
+-
+-        // 2로 0의 개수를 count 할 때
+-        int caseNumTwo = zeroCount(n,2) - zeroCount(m,2) - zeroCount(n-m,2);
+-        // 5로 0의 개수를 count 할 때
+-        int caseNumFive = zeroCount(n,5) -zeroCount(m,5) - zeroCount(n-m,5);
+-
+-        /**
+-         (n
+-         m)의 끝자리 0의 개수*/;
+-         //더 작은 경우의 수
+-        int result = Math.min(caseNumTwo,caseNumFive);
+-        System.out.println(result);
+-        sc.close();
+-    }
+-
+-    // factorial 0의 개수를 카운팅 하는 메소드
+-    // 2 또는 5로 나누어 떨어지는 수의 개수를 카운팅
+-    static Integer zeroCount(int num,int divisor) {
+-        int count = 0;
+-
+-        /**while문**/
+-
+-        // num이 2 또는 5보다 더 작아질 때까지 반복
+-        while (num >= divisor) {
+-            count += num / divisor;
+-            num /= divisor;
+-        }
+-
+-
+-        /**for문으로 할 때는 i의 값이 계속 증가하여 오버플로우 될 수 있으므로 long형으로 해야한다 **/
+-        // i가 num보다 커질 때까지 반복
+-
+-        // (1) 오버 플로우가 나는 예시 코드
+-//        for (int i = divisor; i <= num; i *= divisor) {
+-//            count += num / i;
+-//        }
+-
+-        // (2) 오버 플로우가 안 나도록 long형으로 수정한 코드
+-//        for (long i = divisor; i <= num; i *= divisor) {
+-//            count += num / i;
+-//        }
+-
+-        return count;
+-    }
+-}
+\ No newline at end of file
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,40 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-
+-/** @author bsjin
+- * @date 2023/12/25
+- * @title 백준 10430 나머지
+- *
+- * 문제
+- * (A + B)%C는 ((A%C) + (B%C))%C 와 같을까?
+- * (A×B)%C는 ((A%C) × (B%C))%C 와 같을까?
+- * 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.
+- * 첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.
+- */
+-
+-public class BOJ_10430 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
+-        String[] strArray = str.split(" ");
+-
+-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
+-        int[] intArray = new int[strArray.length];
+-        for (int i = 0; i < strArray.length; i++) {
+-            intArray[i] = Integer.parseInt(strArray[i]);
+-        }
+-
+-        int a = intArray[0];
+-        int b = intArray[1];
+-        int c = intArray[2];
+-
+-        System.out.println((a+b)% c);
+-        System.out.println(((a%c)+(b%c))%c);
+-        System.out.println((a*b)%c);
+-        System.out.println(((a%c)* (b%c))%c);
+-    }
+-}
+Index: src/main/java/coderkim/BOJ/week03/week03_02/zeroCountFactorial_1676/Main.java
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountFactorial_1676/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountFactorial_1676/Main.java
+deleted file mode 100644
+--- a/src/main/java/coderkim/BOJ/week03/week03_02/zeroCountFactorial_1676/Main.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,42 +0,0 @@
+-package main.java.coderkim.BOJ.week03.week03_02.zeroCountFactorial_1676;
+-
+-import java.util.Scanner;
+-
+-/**
+- @Title 팩토리얼 0의 개수(1676)
+- @Since 2024.01.03
+- @Content
+-
+- 문제
+- N!(연산값이)에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.
+-
+- 입력
+- 첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)
+-
+- 출력
+- 첫째 줄에 구한 0의 개수를 출력한다.
+-
+- */
+-public class Main {
+-    public static void main(String[] args) {
+-
+-        Scanner sc = new Scanner(System.in);
+-
+-        int input = sc.nextInt();
+-        int output = 0;
+-
+-        // for문과 while문을 이용한 방법은 숫자가 클 때 너무 성능이 떨어지기 때문에
+-        // 아래와 같은 방법으로 해결했다
+-
+-        // 5의 개수를 센다
+-        // 모든 홀수 숫자에는 2가 하나씩 들어가기 때문에 2의 개수는 항상 5보다 많다
+-        // 따라서 0의 개수는 2와 5의 곱의 개수로 생성되며, 2의 개수는 항상 5보다 많기 때문에 5의 개수로 센다
+-        for(int i = 5; i <= input; i *=5){
+-            output += input / i;
+-        }
+-
+-        System.out.println(output);
+-
+-        sc.close();
+-    }
+-}
+Index: src/main/java/coderkim/BOJ/week03/week03_02/gcdSum_9613/Main.java
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/gcdSum_9613/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/gcdSum_9613/Main.java
+deleted file mode 100644
+--- a/src/main/java/coderkim/BOJ/week03/week03_02/gcdSum_9613/Main.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ /dev/null	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
+@@ -1,62 +0,0 @@
+-package main.java.coderkim.BOJ.week03.week03_02.gcdSum_9613;
+-
+-import java.util.Scanner;
+-
+-/**
+- @Title GCD 합(9613)
+- @Since 2024.01.05
+- @Content 문제
+- 양의 정수 n개가 주어졌을 때, 가능한 모든 쌍의 GCD의 합을 구하는 프로그램을 작성하시오.
+-
+-입력
+- 첫째 줄에 테스트 케이스의 개수 t (1 ≤ t ≤ 100)이 주어진다.
+- 각 테스트 케이스는 한 줄로 이루어져 있다.
+- 각 테스트 케이스는 수의 개수 n (1 < n ≤ 100)가 주어지고, 다음에는 n개의 수가 주어진다.
+- 입력으로 주어지는 수는 1,000,000을 넘지 않는다.
+-
+- 출력
+- 각 테스트 케이스마다 가능한 모든 쌍의 GCD의 합을 출력한다.
+- */
+-
+-public class Main {
+-    // 최대 입력값이 1,000,000까지의 약수 배열을 생성
+-    static int[] divisors = new int[1000001];
+-
+-    // 최대 공약수를 계산하는 메소드
+-    static int gcd(int a, int b) {
+-        if (b == 0) return a;
+-        return gcd(b, a % b);
+-    }
+-
+-    public static void main(String[] args) {
+-        Scanner sc = new Scanner(System.in);
+-
+-        // 1. 첫째 줄에 테스트 케이스의 개수 t (1 ≤ t ≤ 100)이 주어진다.
+-        int t = sc.nextInt();
+-
+-        // case 입력은 총 t번 반복
+-        for (int i = 0; i < t; i++) {
+-            // 2. 각 테스트 케이스는 수의 개수 n (1 < n ≤ 100)가 주어지고, (n = 각 테스트 케이스의 length)
+-            int n = sc.nextInt();
+-            int[] numInCase = new int[n];
+-
+-            // 3. 다음에는 n개의 수가 주어진다 (각 테스트 케이스에 들어가는 숫자 입력)
+-            for (int j = 0; j < n; j++) {
+-                numInCase[j] = sc.nextInt();
+-            }
+-
+-            // GCD 계산 및 약수 배열 초기화
+-            long gcdSum = 0;
+-            for (int x = 0; x < n; x++) {
+-                for (int y = x + 1; y < n; y++) {
+-                    int commonDivisor = gcd(numInCase[x], numInCase[y]);
+-                    gcdSum += commonDivisor;
+-                }
+-            }
+-
+-            // 4. 각 테스트 케이스마다 가능한 모든 쌍의 GCD의 합 결과 출력
+-            System.out.println(gcdSum);
+-        }
+-        sc.close();
+-    }
+-}
+\ No newline at end of file
+Index: src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
+<+>package main.java.coderkim.BOJ.week03.week03_02.hideAndSeek6_17087;\r\n\r\nimport java.util.Scanner;\r\n\r\n/**\r\n @Title 숨바꼭질6(17087)\r\n @Since 2024.01.05\r\n @Content\r\n !!!!!!!!!!!이분탐색!!!!!!(다시 한 번 풀기)\r\n\r\n 문제\r\n 수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.\r\n\r\n 수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.\r\n\r\n 모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.\r\n\r\n 입력\r\n 첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.\r\n\r\n 출력\r\n 가능한 D값의 최댓값을 출력한다.\r\n\r\n */\r\n\r\n//TODO: 다시 풀기.... 이분탐색...\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        int n = scanner.nextInt(); // 동생의 수\r\n        int s = scanner.nextInt(); // 수빈이의 위치\r\n        int[] positions = new int[n];\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            positions[i] = scanner.nextInt(); // 동생들의 위치\r\n        }\r\n\r\n        /** 가능한 D 값 중 최댓값을 찾기 위해 이분 탐색 사용*/\r\n        long left = 0; // D의 최솟값\r\n        long right = 1000000000; // D의 최댓값\r\n        long result = 0;\r\n\r\n        while (left <= right) {\r\n            long mid = (left + right) / 2;\r\n            long time = 0;\r\n\r\n            for (int i = 0; i < n; i++) {\r\n                long distance = Math.abs(positions[i] - s); // 수빈이와 동생 사이의 거리\r\n                long moves = distance / mid; // 걷기로 이동해야 하는 횟수\r\n\r\n                if (distance % mid != 0) {\r\n                    moves++; // 나머지가 남으면 한 번 더 이동\r\n                }\r\n\r\n                time += moves; // 해당 동생을 찾는데 걸리는 총 시간 추가\r\n            }\r\n\r\n            if (time <= mid) {\r\n                result = mid; // 현재 D값으로 모든 동생을 찾을 수 있음\r\n                right = mid - 1; // 더 큰 D값을 찾기 위해 범위를 왼쪽으로 이동\r\n            } else {\r\n                left = mid + 1; // 현재 D값으로는 모든 동생을 찾을 수 없음\r\n            }\r\n        }\r\n\r\n        System.out.println(result);\r\n    }\r\n}
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
+--- a/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java	(revision 44b4b615b6123eee947b7b0697161fe48d138283)
++++ b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java	(date 1705334691593)
+@@ -1,13 +1,11 @@
+ package main.java.coderkim.BOJ.week03.week03_02.hideAndSeek6_17087;
+ 
+-import java.util.Scanner;
+-
+ /**
+  @Title 숨바꼭질6(17087)
+  @Since 2024.01.05
+  @Content
+  !!!!!!!!!!!이분탐색!!!!!!(다시 한 번 풀기)
+-
++ 
+  문제
+  수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.
+ 
+@@ -22,48 +20,8 @@
+  가능한 D값의 최댓값을 출력한다.
+ 
+  */
+-
+-//TODO: 다시 풀기.... 이분탐색...
+ public class Main {
+     public static void main(String[] args) {
+-        Scanner scanner = new Scanner(System.in);
+-
+-        int n = scanner.nextInt(); // 동생의 수
+-        int s = scanner.nextInt(); // 수빈이의 위치
+-        int[] positions = new int[n];
+-
+-        for (int i = 0; i < n; i++) {
+-            positions[i] = scanner.nextInt(); // 동생들의 위치
+-        }
+-
+-        /** 가능한 D 값 중 최댓값을 찾기 위해 이분 탐색 사용*/
+-        long left = 0; // D의 최솟값
+-        long right = 1000000000; // D의 최댓값
+-        long result = 0;
+-
+-        while (left <= right) {
+-            long mid = (left + right) / 2;
+-            long time = 0;
+-
+-            for (int i = 0; i < n; i++) {
+-                long distance = Math.abs(positions[i] - s); // 수빈이와 동생 사이의 거리
+-                long moves = distance / mid; // 걷기로 이동해야 하는 횟수
+-
+-                if (distance % mid != 0) {
+-                    moves++; // 나머지가 남으면 한 번 더 이동
+-                }
+-
+-                time += moves; // 해당 동생을 찾는데 걸리는 총 시간 추가
+-            }
+ 
+-            if (time <= mid) {
+-                result = mid; // 현재 D값으로 모든 동생을 찾을 수 있음
+-                right = mid - 1; // 더 큰 D값을 찾기 위해 범위를 왼쪽으로 이동
+-            } else {
+-                left = mid + 1; // 현재 D값으로는 모든 동생을 찾을 수 없음
+-            }
+-        }
+-
+-        System.out.println(result);
+-    }
+-}
+\ No newline at end of file
++    }
++}
Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
new file mode 100644
--- /dev/null	(date 1705334691609)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java	(date 1705334691609)
@@ -0,0 +1,71 @@
+package main.java.coderkim.BOJ.week05.week05_01.baseConversion2_11005;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Scanner;
+
+/**
+ @Title 진법변환2(11005)
+ @Since 2024.01.15
+ @Content
+ 문제
+ 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.
+
+ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
+
+ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
+
+ 입력
+ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.
+
+ 출력
+ 첫째 줄에 10진법 수 N을 B진법으로 출력한다.
+ */
+
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        String input = sc.nextLine();
+        String[] inputs = input.split(" ");
+        int n = Integer.parseInt(inputs[0]);
+        int b = Integer.parseInt(inputs[1]);
+
+        List<Character> list = new ArrayList<>();
+        while (n > 0) {
+            if (n % b < 10) {
+                list.add((char) (n % b + '0'));
+            } else {
+                list.add((char) (n % b - 10 + 'A'));
+            }
+            n /= b;
+        }
+
+        for (int i = list.size() - 1; i >= 0; i--) {
+            System.out.print(list.get(i));
+        }
+        sc.close();
+    }
+}
+//TODO:
+// 내장메소드를 이용한 방법... 왜 오류 나지??
+    //public class Main{
+//    public static void main(String[] args) {
+//        Scanner sc = new Scanner(System.in);
+//
+//        String input = sc.nextLine();
+//        String[] inputs = input.split(" ");
+//
+//        // 10진법 숫자
+//        Integer N = Integer.parseInt(inputs[0]);
+//        // 변환할 진법 숫자
+//        int B = Integer.parseInt(inputs[1]);
+//
+//        String result = Integer.toString(N,B);
+//
+//        System.out.println(result);
+//
+//        sc.close();
+//
+//    }
+//}
Index: src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
new file mode 100644
--- /dev/null	(date 1705334691598)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java	(date 1705334691598)
@@ -0,0 +1,70 @@
+package main.java.coderkim.BOJ.week04.week04_01.goldbachPartition_17103;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Scanner;
+
+/**
+ @Title 골드바흐 파티션(17103)
+ @Since 2024.01.13
+ @Content
+ 문제
+ 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다. (소수 : 1과 자신만 약수로 갖고 있는 수)
+ 짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때,골드바흐 파티션의 개수를 구해보자.
+ 두 소수의 순서만 다른 것은 같은 파티션이다.
+
+ 입력
+ 첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.
+
+ 출력
+ 각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.
+
+ */
+
+//TODO: 에라토스테네스 체와 관련된 문제 다시 풀기
+public class Main {
+    // 에라토스테네스의 체를 사용하여 소수를 구하는 함수
+    public static boolean[] sieveOfEratosthenes(int n) {
+        boolean[] isPrime = new boolean[n + 1];
+        for (int i = 2; i <= n; i++) {
+            isPrime[i] = true;
+        }
+        for (int i = 2; i * i <= n; i++) {
+            if (isPrime[i]) {
+                for (int j = i * i; j <= n; j += i) {
+                    isPrime[j] = false;
+                }
+            }
+        }
+        return isPrime;
+    }
+
+    // 골드바흐 파티션 개수를 구하는 함수
+    public static int goldbachPartitions(int n, boolean[] isPrime) {
+        int count = 0;
+        for (int i = 2; i <= n / 2; i++) {
+            if (isPrime[i] && isPrime[n - i]) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int T = sc.nextInt(); // 테스트 케이스의 개수
+
+        // 소수 판별을 위한 에라토스테네스의 체 적용
+        int maxN = 1000000; // 주어진 최대 N값
+        boolean[] isPrime = sieveOfEratosthenes(maxN);
+
+        for (int i = 0; i < T; i++) {
+            int N = sc.nextInt(); // 짝수 N
+            int partitions = goldbachPartitions(N, isPrime);
+            System.out.println(partitions);
+        }
+
+        sc.close();
+    }
+}
+
Index: src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
new file mode 100644
--- /dev/null	(date 1705334691614)
+++ b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java	(date 1705334691614)
@@ -0,0 +1,39 @@
+package main.java.coderkim.BOJ.week05.week05_01.factorization_11653;
+import java.util.Scanner;
+/**
+ @Title 소인수분해(11653)
+ @Since 2024.01.15
+ @Content
+ 문제
+ 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
+
+ 출력
+ N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+        int N = sc.nextInt();
+
+        if (N == 1) {
+            // N이 1인 경우 아무것도 출력하지 않음
+        } else {
+            int divisor = 2; // 시작 소수로 2부터 시작
+            while (N > 1) {
+                if (N % divisor == 0) {
+                    // N이 현재의 divisor로 나누어떨어지면 소인수임
+                    System.out.println(divisor);
+                    N /= divisor;
+                } else {
+                    // 나누어떨어지지 않으면 다음 소수로 넘어감
+                    divisor++;
+                }
+            }
+        }
+
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
new file mode 100644
--- /dev/null	(date 1705334691604)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java	(date 1705334691604)
@@ -0,0 +1,53 @@
+package main.java.coderkim.BOJ.week04.week04_01.octalToBinary_1212;
+
+import java.util.Scanner;
+
+
+/**
+ @Title 8진수 2진수(1212)
+ @Since 2024.01.12
+ @Content
+
+ 문제
+ 8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 8진수가 주어진다. 주어지는 수의 길이는 333,334을 넘지 않는다.
+
+ 출력
+ 첫째 줄에 주어진 수를 2진수로 변환하여 출력한다. 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다.
+ */
+public class Main {
+    public static void main(String[] args) {
+
+        Scanner sc = new Scanner(System.in);
+        String input = sc.nextLine();
+        int length = input.length();
+        StringBuilder sb = new StringBuilder();
+        String[] inputs = input.split("");
+            // 8진수를 2진수로 바꿔준다
+        for (int i = 0; i < length; i++) {
+            int octalValue = Integer.parseInt(inputs[i]);
+            String binaryValue = Integer.toBinaryString(octalValue);
+
+            // 2진수 자리 3자리로 맞춰준다
+            if(binaryValue.length() == 2 && i != 0)
+                binaryValue = "0" + binaryValue;
+            else if(binaryValue.length() == 1 && i !=0)
+                binaryValue = "00" + binaryValue;
+
+            // 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다
+            // 첫 번째 자리수가 0이면 뺴준다
+            if(!binaryValue.equals("0")){
+                if( i == 0 && binaryValue.startsWith("0") && binaryValue.startsWith("00")){
+                    binaryValue = binaryValue.substring(1,binaryValue.length());
+                }
+
+            }
+            sb.append(binaryValue);
+        }
+        String result = sb.toString();
+        System.out.println(result);
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
new file mode 100644
--- /dev/null	(date 1705334691601)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java	(date 1705334691601)
@@ -0,0 +1,50 @@
+package main.java.coderkim.BOJ.week04.week04_01.nagativeBinary_2089;
+
+import java.util.Scanner;
+
+/**
+ @Title -2진법(2089)
+ @Since 2024.01.13
+ @Content
+ 문제
+ -2진법은 부호 없는 2진수로 표현이 된다.
+ 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다.
+ 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.
+
+ 10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.
+
+ 입력
+ 첫 줄에 10진법으로 표현된 수 N이 주어진다.
+
+ 출력
+ -2진법 수를 출력한다.
+
+ */
+public class Main {
+    public static void main(String[] args) {
+
+        Scanner sc = new Scanner(System.in);
+
+        String input = sc.nextLine();
+        StringBuilder sb = new StringBuilder();
+        int n = Integer.parseInt(input);
+        if(n == 0){
+            sb.append(n);
+        }else{
+            // 마지막 몫이 1일 떄까지 반복
+            while(n != 1){
+                // 나머지는 반드시 양수여야 하기 때문에 절대값 반환
+                sb.append(Math.abs(n % (-2)));
+                n = (int) Math.ceil((double) n / (-2));
+            }
+
+            // 마지막 몫이 1일 때의 나머지도 추가 해줘야 함
+            sb.append(n);
+        }
+
+        // sb를 뒤집어서 출력
+        // -2진법 출력
+        System.out.println(sb.reverse());
+        sc.close();
+    }
+}
Index: src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
new file mode 100644
--- /dev/null	(date 1705334691596)
+++ b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java	(date 1705334691596)
@@ -0,0 +1,49 @@
+package main.java.coderkim.BOJ.week04.week04_01.binaryToOctal_1373;
+import java.util.Scanner;
+
+/**
+ @Title 2진수 8진수(1373)
+ @Since 2024.01.07
+ @Content 문제
+ 2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오.
+
+ 입력
+ 첫째 줄에 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다.
+
+ 출력
+ 첫째 줄에 주어진 수를 8진수로 변환하여 출력한다.
+
+ 참고 <a href="https://m.blog.naver.com/javrin4/220956809081">...</a>
+
+ */
+public class Main {
+    public static void main(String[] args) {
+        Scanner sc = new Scanner(System.in);
+
+        // 입력
+        // 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다
+        String input = sc.nextLine();
+        int length = input.length();
+        // 8진수를 담기 위한 객체
+        StringBuilder octalStringBuilder = new StringBuilder();
+        // 8진수는 2의 3제곱. 뒤에서부터 숫자를 3자리씩 묶어준 그룹을 2진수 8진수 로 변환.
+        // 모자른 자리는 0을 플러스 해준다
+        for (int i = length; i > 0; i -= 3) {
+            String group = input.substring(Math.max(i - 3, 0),i);
+            if(group.length() < 3){
+                group = "0" + group;
+            }
+            int decimal = Integer.parseInt(group, 2);
+            octalStringBuilder.append(decimal);
+        }
+
+        // 저장된 순서가 거꾸로이기 때문에 뒤집어준다.
+        String octal = octalStringBuilder.reverse().toString();
+
+        System.out.println(octal);
+
+        sc.close();
+
+
+    }
+}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1705333649987)
+++ b/.idea/misc.xml	(date 1705333649987)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="17" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1705333447162)
+++ b/.idea/encodings.xml	(date 1705333447162)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="PROJECT" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/shelf/________.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/shelf/________.xml b/.idea/shelf/________.xml
new file mode 100644
--- /dev/null	(date 1705333521311)
+++ b/.idea/shelf/________.xml	(date 1705333521311)
@@ -0,0 +1,4 @@
+<changelist name="리베이스_전에_커밋되지_않은_변경_내용_[변경]" date="1705333329607" recycled="true" deleted="true">
+  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/리베이스_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch" />
+  <option name="DESCRIPTION" value="리베이스 전에 커밋되지 않은 변경 내용 [변경]" />
+</changelist>
\ No newline at end of file
Index: CodingTest.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CodingTest.iml b/CodingTest.iml
new file mode 100644
--- /dev/null	(date 1705333703990)
+++ b/CodingTest.iml	(date 1705333703990)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id="$MODULE_DIR$/pom.xml" external.system.module.type="SINGLE_MODULE" external.system.module.version="223-2" org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_17">
+    <output url="file://$MODULE_DIR$/target/classes" />
+    <output-test url="file://$MODULE_DIR$/target/test-classes" />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/target/generated-sources/annotations" isTestSource="false" generated="true" />
+      <excludeFolder url="file://$MODULE_DIR$/target" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1705333907920)
+++ b/.idea/vcs.xml	(date 1705333907920)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/shelf/리베이스_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/shelf/리베이스_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch b/.idea/shelf/리베이스_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch
new file mode 100644
--- /dev/null	(date 1705332776652)
+++ b/.idea/shelf/리베이스_전에_커밋되지_않은_변경_내용_[변경]/shelved.patch	(date 1705332776652)
@@ -0,0 +1,1217 @@
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_10799.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,35 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.util.Scanner;
+-import java.util.Stack;
+-
+-// 쇠막대기
+-public class BOJ_10799 {
+-    public static void main(String[] args) {
+-        Scanner sc = new Scanner(System.in);
+-
+-        String input = sc.next();
+-
+-        int result = 0;
+-
+-        Stack<Character> stack = new Stack<>();
+-
+-        for(int i =0; i<input.length(); i++){
+-            if(input.charAt(i) == '('){
+-                stack.push('(');
+-            }else if(input.charAt(i)==')'){
+-                stack.pop();
+-            }
+-
+-            if(i >0){
+-                if(input.charAt(i-1) == '(' && input.charAt(i) ==')'){
+-                    result += stack.size();
+-                }else if(input.charAt(i-1) == ')' && input.charAt(i) == ')'){
+-                    result++;
+-                }
+-            }
+-        }
+-        System.out.println(result);
+-    }
+-}
+-
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17413.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,57 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.Stack;
+-
+-// 단어뒤집기2
+-public class BOJ_17413 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-
+-
+-        String str = br.readLine(); // 문자열 S입력
+-        StringBuilder sb = new StringBuilder(); // 결과 값을 출력할 StringBuilder
+-        Stack<Character> stack = new Stack <> (); // 후입선출 기능을 이용하기 위한 자료구조 Stack
+-        boolean flag = false;
+-
+-        for(int i =0; i < str.length(); i++){
+-            if(str.charAt(i) == '<'){
+-                while(!stack.isEmpty()){
+-                    sb.append(stack.pop());
+-                }
+-                flag = true;
+-            }
+-            else if(str.charAt(i) == '>'){
+-                flag = false;
+-                sb.append(str.charAt(i));
+-                continue;
+-            }
+-
+-            if(flag == true){
+-                sb.append(str.charAt(i));
+-            }else if(flag == false) {
+-                if (str.charAt(i) == ' ') {
+-                    while (!stack.isEmpty()) {
+-                        sb.append(stack.pop());
+-                    }
+-                    sb.append(' ');
+-                    continue;
+-                } else {
+-                    stack.push(str.charAt(i));
+-                }
+-            }
+-
+-            if(i == str.length() - 1){
+-                while (!stack.isEmpty()) {
+-                    sb.append(stack.pop());
+-                }
+-            }
+-        }
+-        // 결과문 출력
+-        System.out.println(sb);
+-
+-
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_1934.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,74 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.ArrayList;
+-import java.util.Scanner;
+-import java.util.StringTokenizer;
+-
+-public class BOJ_1934 {
+-    /**
+-     * @author bsjin
+-     * @date 2023/12/25
+-     * @title 백준 1934 최소공배수
+-     *
+-     * 문제
+-     * 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다.
+-     * 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
+-     * 두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
+-     *
+-     * 입력: 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
+-     * 출력: 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.
+-     */
+-    public static void main(String[] args) throws IOException {
+-        // 입력은 InputStreamReader를 통해 '문자'를 'char'타입으로 byte단위로 받는다(InputStream 객체로)
+-        // 받은 'char'타입 문자들을 BufferedReader를 통해 직렬화('String'타입으로 변환)한다.
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-
+-        // 입력받은 문자열을 Intger 데이터타입으로 변환한다.(기본형 String)
+-        int N = Integer.parseInt(br.readLine());
+-
+-        // 문자들을 입력받아 String을 만들 StringBuilder선언
+-        // String은 불변의 객체이기 때문에 새로만들거나 합칠때마다
+-        // 새로운 문자열을 참조하기에 비효율적이다.
+-        StringBuilder sb = new StringBuilder();
+-
+-        // String을 delim(delimiter)으로 분리하여 토큰화합니다.
+-        // delim으로는 기본적인 공백문자인 \t(가로탭), \n(줄바꿈), \r(캐리지 리턴) 등이 있습니다.
+-        StringTokenizer st;
+-
+-        for(int i = 0; i < N; i++) {
+-            // 공백 기준으로 토큰화(한번에 입력받음)
+-            st = new StringTokenizer(br.readLine(), " ");
+-
+-            // String토큰들을 Intger로 형변환
+-            int a = Integer.parseInt(st.nextToken());
+-            int b = Integer.parseInt(st.nextToken());
+-
+-            // 정적메소드 gcd 실행결과인 최대공약수를 d변수에 입력
+-            int d = gcd(a, b);
+-
+-            // 유클리드 호제법 사용
+-            // 결과를 StringBuilder에 입력하고 줄바꿈을 붙인다.
+-            sb.append(a * b / d).append('\n');
+-        }
+-        // 반복문 종료후 결과값들이 들어있는 sb출력
+-        System.out.println(sb);
+-
+-    }
+-
+-    // 최대공약수 반복문 방식
+-    public static int gcd(int a, int b) {
+-
+-        while (b != 0) {
+-            int r = a % b; // 나머지를 구해준다.
+-
+-            // GCD(a, b) = GCD(b, r)이므로 변환한다.
+-            a = b;
+-            b = r;
+-        }
+-        return a;
+-    }
+-
+-}
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17298.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,47 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.*;
+-import java.util.stream.Collectors;
+-import java.util.stream.IntStream;
+-
+-// 오큰수
+-// data[] 에 값을 넣고 해당 인덱스의 값과 그 다음 data[i]번째 값보다 작으면(stack이 비어있지 않은 상태에서)
+-// stack을 pop 한 인덱스의 값이 = data[i]가 된다.
+-// false인 경우엔 stack에 i값 넣기
+-public class BOJ_17298 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        StringBuffer sb = new StringBuffer();
+-
+-        int N = Integer.parseInt(br.readLine()); // 입력할 숫자의 수
+-        int[] data = new int[N]; // 숫자 수만큼 배열 생성
+-
+-        StringTokenizer st = new StringTokenizer(br.readLine());
+-
+-        for(int i =0; i<N; i++){
+-            data[i] = Integer.parseInt(st.nextToken()); // 쪼개진 숫자만큼 배열에 넣기
+-        }
+-
+-        Stack<Integer> stack = new Stack<>(); // 스택 할당
+-
+-        for(int i =0; i<N; i++){
+-            while(!stack.isEmpty() && data[stack.peek()] < data[i]){
+-                data[stack.pop()] = data[i];
+-            }
+-            stack.add(i);
+-        }
+-        while(!stack.isEmpty()) {
+-            data[stack.pop()] = -1;
+-        }
+-        for(int i = 0; i < N; i++){
+-            sb.append(data[i]).append(" ");
+-        }
+-
+-        System.out.println(sb);
+-
+-    }
+-
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_11656.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,37 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.ArrayList;
+-import java.util.Collections;
+-import java.util.List;
+-/**
+- * @author bsjin
+- * @date 2023/12/25
+- * @note 백준 203-자료구조1 접미사 배열(11656)
+- */
+-
+-/**
+- * 문제: 접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.
+- baekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.
+- 문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.
+- *
+- */
+-public class BOJ_11656 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        List<String> arrList = new ArrayList<>();
+-
+-        for(int i = 0; i < str.length(); i++){
+-            arrList.add(str.substring(i)); // 문자열을 잘라서 arrayList에 넣는다.
+-        }
+-
+-        Collections.sort(arrList); // 알파벳 순으로 정렬
+-
+-        for(String string : arrList){ // 출력
+-            System.out.println(string);
+-        }
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_10430.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,40 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-
+-/** @author bsjin
+- * @date 2023/12/25
+- * @title 백준 10430 나머지
+- *
+- * 문제
+- * (A + B)%C는 ((A%C) + (B%C))%C 와 같을까?
+- * (A×B)%C는 ((A%C) × (B%C))%C 와 같을까?
+- * 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.
+- * 첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.
+- */
+-
+-public class BOJ_10430 {
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
+-        String[] strArray = str.split(" ");
+-
+-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
+-        int[] intArray = new int[strArray.length];
+-        for (int i = 0; i < strArray.length; i++) {
+-            intArray[i] = Integer.parseInt(strArray[i]);
+-        }
+-
+-        int a = intArray[0];
+-        int b = intArray[1];
+-        int c = intArray[2];
+-
+-        System.out.println((a+b)% c);
+-        System.out.println(((a%c)+(b%c))%c);
+-        System.out.println((a*b)%c);
+-        System.out.println(((a%c)* (b%c))%c);
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java b/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week02/BOJ_2609.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,46 +0,0 @@
+-package bsjin1122.BOJ.week02;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-
+-public class BOJ_2609 {
+-    /**
+-     * @author bsjin
+-     * @date 2023/12/25
+-     * @title 백준 2609 최대공약수와 최소공배수
+-     *
+-     * 문제
+-     * 두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
+-     * 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
+-     */
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        String str = br.readLine(); // 문자열 S입력
+-        // 공백을 기준으로 문자열을 분리하여 문자열 배열로 만듭니다.
+-        String[] strArray = str.split(" ");
+-
+-        // int 배열을 선언하여 문자열 배열을 int로 변환하여 담습니다.
+-        int[] intArray = new int[strArray.length];
+-        for (int i = 0; i < strArray.length; i++) {
+-            intArray[i] = Integer.parseInt(strArray[i]);
+-        }
+-
+-        System.out.println(gcd(intArray[0], intArray[1]));
+-        System.out.println(lcm(intArray[0], intArray[1]));
+-
+-
+-    }
+-    public static int gcd(int a, int b) { // 최대공약수
+-        while (b != 0) {
+-            int temp = b;
+-            b = a % b;
+-            a = temp;
+-        }
+-        return a;
+-    }
+- 
+-    public static int lcm(int a, int b) { //최소공배수
+-        return (a * b) / gcd(a, b);
+-    }
+-}
+Index: src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
+===================================================================
+diff --git a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java b/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java
+deleted file mode 100644
+--- a/src/main/java/bsjin1122/BOJ/week01/BOJ_17299.java	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
++++ /dev/null	(revision 4adb54d668f562f6bd914fd99ec323dcfafb0cb7)
+@@ -1,45 +0,0 @@
+-package bsjin1122.BOJ.week01;
+-
+-import java.io.BufferedReader;
+-import java.io.IOException;
+-import java.io.InputStreamReader;
+-import java.util.Stack;
+-import java.util.StringTokenizer;
+-
+-// 오등큰수
+-public class BOJ_17299 {
+-    static final int MAX = 1_000_001;
+-
+-    public static void main(String[] args) throws IOException {
+-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+-        Stack<Integer> stack = new Stack<>();
+-        int n = Integer.parseInt(br.readLine());
+-        int count[] = new int[MAX];
+-        int index[] = new int[n];
+-        int ans[] = new int[n];
+-
+-        StringTokenizer st = new StringTokenizer(br.readLine());
+-        for(int i = 0; i < n; i++){
+-            index[i] = Integer.parseInt(st.nextToken());
+-            count[index[i]]++;
+-        }
+-        for(int i = 0; i< n; i++){
+-            while(!stack.isEmpty() && count[index[i]] > count[index[stack.peek()]]){
+-                ans[stack.pop()] = index[i];
+-            }
+-            stack.push(i);
+-        }
+-
+-        while(!stack.isEmpty()){
+-            ans[stack.pop()] = -1;
+-        }
+-
+-        StringBuilder sb = new StringBuilder();
+-
+-        for(int i = 0; i < n; i++){
+-            sb.append(ans[i] + " ");
+-        }
+-        System.out.println(sb.toString());
+-
+-    }
+-}
+Index: src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640015)
++++ b/src/main/java/coderkim/BOJ/week04/week04_01/nagativeBinary_2089/Main.java	(date 1705332640015)
+@@ -0,0 +1,50 @@
++package main.java.coderkim.BOJ.week04.week04_01.nagativeBinary_2089;
++
++import java.util.Scanner;
++
++/**
++ @Title -2진법(2089)
++ @Since 2024.01.13
++ @Content
++ 문제
++ -2진법은 부호 없는 2진수로 표현이 된다.
++ 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다.
++ 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.
++
++ 10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.
++
++ 입력
++ 첫 줄에 10진법으로 표현된 수 N이 주어진다.
++
++ 출력
++ -2진법 수를 출력한다.
++
++ */
++public class Main {
++    public static void main(String[] args) {
++
++        Scanner sc = new Scanner(System.in);
++
++        String input = sc.nextLine();
++        StringBuilder sb = new StringBuilder();
++        int n = Integer.parseInt(input);
++        if(n == 0){
++            sb.append(n);
++        }else{
++            // 마지막 몫이 1일 떄까지 반복
++            while(n != 1){
++                // 나머지는 반드시 양수여야 하기 때문에 절대값 반환
++                sb.append(Math.abs(n % (-2)));
++                n = (int) Math.ceil((double) n / (-2));
++            }
++
++            // 마지막 몫이 1일 때의 나머지도 추가 해줘야 함
++            sb.append(n);
++        }
++
++        // sb를 뒤집어서 출력
++        // -2진법 출력
++        System.out.println(sb.reverse());
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640017)
++++ b/src/main/java/coderkim/BOJ/week04/week04_01/octalToBinary_1212/Main.java	(date 1705332640017)
+@@ -0,0 +1,53 @@
++package main.java.coderkim.BOJ.week04.week04_01.octalToBinary_1212;
++
++import java.util.Scanner;
++
++
++/**
++ @Title 8진수 2진수(1212)
++ @Since 2024.01.12
++ @Content
++
++ 문제
++ 8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오.
++
++ 입력
++ 첫째 줄에 8진수가 주어진다. 주어지는 수의 길이는 333,334을 넘지 않는다.
++
++ 출력
++ 첫째 줄에 주어진 수를 2진수로 변환하여 출력한다. 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다.
++ */
++public class Main {
++    public static void main(String[] args) {
++
++        Scanner sc = new Scanner(System.in);
++        String input = sc.nextLine();
++        int length = input.length();
++        StringBuilder sb = new StringBuilder();
++        String[] inputs = input.split("");
++            // 8진수를 2진수로 바꿔준다
++        for (int i = 0; i < length; i++) {
++            int octalValue = Integer.parseInt(inputs[i]);
++            String binaryValue = Integer.toBinaryString(octalValue);
++
++            // 2진수 자리 3자리로 맞춰준다
++            if(binaryValue.length() == 2 && i != 0)
++                binaryValue = "0" + binaryValue;
++            else if(binaryValue.length() == 1 && i !=0)
++                binaryValue = "00" + binaryValue;
++
++            // 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다
++            // 첫 번째 자리수가 0이면 뺴준다
++            if(!binaryValue.equals("0")){
++                if( i == 0 && binaryValue.startsWith("0") && binaryValue.startsWith("00")){
++                    binaryValue = binaryValue.substring(1,binaryValue.length());
++                }
++
++            }
++            sb.append(binaryValue);
++        }
++        String result = sb.toString();
++        System.out.println(result);
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640020)
++++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion1_2745/Main.java	(date 1705332640020)
+@@ -0,0 +1,46 @@
++package main.java.coderkim.BOJ.week05.week05_01.baseConversion1_2745;
++
++import java.util.Scanner;
++
++/**
++ @Title 진법변환(2745)
++ @Since 2024.01.15
++ @Content
++ 문제
++ B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
++
++ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
++
++ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
++
++ 입력
++ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
++
++ B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.
++
++ 출력
++ 첫째 줄에 B진법 수 N을 10진법으로 출력한다.
++
++ */
++
++// 내장메소드를 이용한 방법
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        // B진법 수 N이 주어진다.
++        // 입력 : 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
++        // N , B를 입력
++        String input = sc.nextLine();
++        String[] inputs = input.split(" ");
++
++        String N = inputs[0];
++        int B = Integer.parseInt(inputs[1]);
++
++        int decimalValue = Integer.parseInt(N,B);
++
++        System.out.println(decimalValue);
++        sc.close();
++
++    }
++}
+Index: src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640026)
++++ b/src/main/java/coderkim/BOJ/week05/week05_01/factorization_11653/Main.java	(date 1705332640026)
+@@ -0,0 +1,39 @@
++package main.java.coderkim.BOJ.week05.week05_01.factorization_11653;
++import java.util.Scanner;
++/**
++ @Title 소인수분해(11653)
++ @Since 2024.01.15
++ @Content
++ 문제
++ 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
++
++ 입력
++ 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
++
++ 출력
++ N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.
++ */
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++        int N = sc.nextInt();
++
++        if (N == 1) {
++            // N이 1인 경우 아무것도 출력하지 않음
++        } else {
++            int divisor = 2; // 시작 소수로 2부터 시작
++            while (N > 1) {
++                if (N % divisor == 0) {
++                    // N이 현재의 divisor로 나누어떨어지면 소인수임
++                    System.out.println(divisor);
++                    N /= divisor;
++                } else {
++                    // 나누어떨어지지 않으면 다음 소수로 넘어감
++                    divisor++;
++                }
++            }
++        }
++
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640012)
++++ b/src/main/java/coderkim/BOJ/week04/week04_01/goldbachPartition_17103/Main.java	(date 1705332640012)
+@@ -0,0 +1,70 @@
++package main.java.coderkim.BOJ.week04.week04_01.goldbachPartition_17103;
++
++import java.util.ArrayList;
++import java.util.List;
++import java.util.Scanner;
++
++/**
++ @Title 골드바흐 파티션(17103)
++ @Since 2024.01.13
++ @Content
++ 문제
++ 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다. (소수 : 1과 자신만 약수로 갖고 있는 수)
++ 짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때,골드바흐 파티션의 개수를 구해보자.
++ 두 소수의 순서만 다른 것은 같은 파티션이다.
++
++ 입력
++ 첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.
++
++ 출력
++ 각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.
++
++ */
++
++//TODO: 에라토스테네스 체와 관련된 문제 다시 풀기
++public class Main {
++    // 에라토스테네스의 체를 사용하여 소수를 구하는 함수
++    public static boolean[] sieveOfEratosthenes(int n) {
++        boolean[] isPrime = new boolean[n + 1];
++        for (int i = 2; i <= n; i++) {
++            isPrime[i] = true;
++        }
++        for (int i = 2; i * i <= n; i++) {
++            if (isPrime[i]) {
++                for (int j = i * i; j <= n; j += i) {
++                    isPrime[j] = false;
++                }
++            }
++        }
++        return isPrime;
++    }
++
++    // 골드바흐 파티션 개수를 구하는 함수
++    public static int goldbachPartitions(int n, boolean[] isPrime) {
++        int count = 0;
++        for (int i = 2; i <= n / 2; i++) {
++            if (isPrime[i] && isPrime[n - i]) {
++                count++;
++            }
++        }
++        return count;
++    }
++
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++        int T = sc.nextInt(); // 테스트 케이스의 개수
++
++        // 소수 판별을 위한 에라토스테네스의 체 적용
++        int maxN = 1000000; // 주어진 최대 N값
++        boolean[] isPrime = sieveOfEratosthenes(maxN);
++
++        for (int i = 0; i < T; i++) {
++            int N = sc.nextInt(); // 짝수 N
++            int partitions = goldbachPartitions(N, isPrime);
++            System.out.println(partitions);
++        }
++
++        sc.close();
++    }
++}
++
+Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640024)
++++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion3_11576/Main.java	(date 1705332640024)
+@@ -0,0 +1,71 @@
++package main.java.coderkim.BOJ.week05.week05_01.baseConversion3_11576;
++
++import java.util.Scanner;
++import java.util.Stack;
++
++/**
++ @Title Base Conversion(11576)
++ @Since 2024.01.15
++ @Content
++
++ 문제
++ 타임머신을 개발하는 정이는 오랜 노력 끝에 타임머신을 개발하는데 성공하였다.
++ 미래가 궁금한 정이는 자신이 개발한 타임머신을 이용하여 500년 후의 세계로 여행을 떠나게 되었다.
++ 500년 후의 세계에서도 프로그래밍을 하고 싶었던 정이는 백준 사이트에 접속하여 문제를 풀기로 하였다.
++ 그러나 미래세계는 A진법을 사용하고 있었고, B진법을 사용하던 정이는 문제를 풀 수가 없었다.
++ 뛰어난 프로그래머였던 정이는 A진법으로 나타낸 숫자를 B진법으로 변환시켜주는 프로그램을 작성하기로 하였다.
++
++ N진법이란, 한 자리에서 숫자를 표현할 때 쓸 수 있는 숫자의 가짓수가 N이라는 뜻이다.
++ 예를 들어 N이 17일 때 한 자릿수에서 사용할 수 있는 수는 0, 1, 2, ... , 16으로 총 17가지가 된다.
++
++ 입력
++ 입력의 첫 줄에는 미래세계에서 사용하는 진법 A와 정이가 사용하는 진법 B가 공백을 구분으로 주어진다. A와 B는 모두 2이상 30이하의 자연수다.
++
++ 입력의 두 번째 줄에는 A진법으로 나타낸 숫자의 자리수의 개수 m(1 ≤ m ≤ 25)이 주어진다.
++ 세 번째 줄에는 A진법을 이루고 있는 숫자 m개가 공백을 구분으로 높은 자릿수부터 차례대로 주어진다.
++ 각 숫자는 0이상 A미만임이 보장된다. 또한 수가 0으로 시작하는 경우는 존재하지 않는다.
++
++ A진법으로 나타낸 수를 10진법으로 변환하였을 때의 값은 양의 정수이며 220보다 작다.
++
++ 출력
++ 입력으로 주어진 A진법으로 나타낸 수를 B진법으로 변환하여 출력한다.
++ */
++//TODO: 다시 풀기
++public class Main {
++
++    static Stack<Integer> stack = new Stack<>();
++
++    static public void main(String args[]) {
++        Scanner sc = new Scanner(System.in);
++        int base_A = sc.nextInt();
++        int base_B = sc.nextInt();
++        int index = sc.nextInt();
++
++        int decimalNum = 0;
++
++        for(int i = index-1; i>=0; i--){
++            int x = sc.nextInt();
++            decimalNum += x * Math.pow(base_A, i);
++        }
++
++        convertBase(decimalNum, base_B);
++
++        int size = stack.size();
++        for(int i = 0; i<size; i++){
++            if(i == size-1)
++                System.out.print(stack.pop());
++            else
++                System.out.print(stack.pop() + " ");
++        }
++    }
++
++    static void convertBase(int decimalNum, int base) {
++        int num = decimalNum;
++
++        while (num != 0) {
++            int r = num % base;
++            num /= base;
++            stack.push(r);
++        }
++    }
++}
+\ No newline at end of file
+Index: src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332655585)
++++ b/src/main/java/coderkim/BOJ/week03/week03_02/hideAndSeek6_17087/Main.java	(date 1705332655585)
+@@ -0,0 +1,27 @@
++package main.java.coderkim.BOJ.week03.week03_02.hideAndSeek6_17087;
++
++/**
++ @Title 숨바꼭질6(17087)
++ @Since 2024.01.05
++ @Content
++ !!!!!!!!!!!이분탐색!!!!!!(다시 한 번 풀기)
++ 
++ 문제
++ 수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.
++
++ 수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.
++
++ 모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.
++
++ 입력
++ 첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.
++
++ 출력
++ 가능한 D값의 최댓값을 출력한다.
++
++ */
++public class Main {
++    public static void main(String[] args) {
++
++    }
++}
+Index: src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640022)
++++ b/src/main/java/coderkim/BOJ/week05/week05_01/baseConversion2_11005/Main.java	(date 1705332640022)
+@@ -0,0 +1,71 @@
++package main.java.coderkim.BOJ.week05.week05_01.baseConversion2_11005;
++
++import java.util.ArrayList;
++import java.util.List;
++import java.util.Scanner;
++
++/**
++ @Title 진법변환2(11005)
++ @Since 2024.01.15
++ @Content
++ 문제
++ 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.
++
++ 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
++
++ A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
++
++ 입력
++ 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.
++
++ 출력
++ 첫째 줄에 10진법 수 N을 B진법으로 출력한다.
++ */
++
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        String input = sc.nextLine();
++        String[] inputs = input.split(" ");
++        int n = Integer.parseInt(inputs[0]);
++        int b = Integer.parseInt(inputs[1]);
++
++        List<Character> list = new ArrayList<>();
++        while (n > 0) {
++            if (n % b < 10) {
++                list.add((char) (n % b + '0'));
++            } else {
++                list.add((char) (n % b - 10 + 'A'));
++            }
++            n /= b;
++        }
++
++        for (int i = list.size() - 1; i >= 0; i--) {
++            System.out.print(list.get(i));
++        }
++        sc.close();
++    }
++}
++//TODO:
++// 내장메소드를 이용한 방법... 왜 오류 나지??
++    //public class Main{
++//    public static void main(String[] args) {
++//        Scanner sc = new Scanner(System.in);
++//
++//        String input = sc.nextLine();
++//        String[] inputs = input.split(" ");
++//
++//        // 10진법 숫자
++//        Integer N = Integer.parseInt(inputs[0]);
++//        // 변환할 진법 숫자
++//        int B = Integer.parseInt(inputs[1]);
++//
++//        String result = Integer.toString(N,B);
++//
++//        System.out.println(result);
++//
++//        sc.close();
++//
++//    }
++//}
+Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640029)
++++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN1_11726/Main.java	(date 1705332640029)
+@@ -0,0 +1,39 @@
++package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN1_11726;
++
++import java.util.Scanner;
++
++/**
++ @Title 2 x N 타일링1(11726)
++ @Since 2024.01.14
++ @Content
++ 문제
++ 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
++
++ 아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.
++
++ 입력
++ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
++
++ 출력
++ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
++ */
++//TODO:동적계획법
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        int n = sc.nextInt();
++        int[] dp = new int[n + 1];
++        int mod = 10007;
++
++        dp[1] = 1;
++        if (n > 1) dp[2] = 2;
++
++        for (int i = 3; i <= n; i++) {
++            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
++        }
++
++        System.out.println(dp[n]);
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640033)
++++ b/src/main/java/coderkim/BOJ/week05/week05_02/makeItOne_1463/Main.java	(date 1705332640033)
+@@ -0,0 +1,37 @@
++package main.java.coderkim.BOJ.week05.week05_02.makeItOne_1463;
++
++import java.util.Scanner;
++
++/**
++  @Title 1로 만들기(1463)
++  @Since 2024.01.14
++  @Content 문제
++  정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
++  X가 3으로 나누어 떨어지면, 3으로 나눈다.
++  X가 2로 나누어 떨어지면, 2로 나눈다.
++  1을 뺀다.
++  정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
++  입력
++  첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
++  출력
++  첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
++ */
++
++//TODO: 동적 계획법 알고리즘
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        int N = sc.nextInt();
++        int[] dp = new int[N + 1];
++
++        for (int i = 2; i <= N; i++) {
++            dp[i] = dp[i - 1] + 1;
++            if (i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
++            if (i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
++        }
++
++        System.out.println(dp[N]);
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640035)
++++ b/src/main/java/coderkim/BOJ/week05/week05_02/oneTwoThreeSum_9095/Main.java	(date 1705332640035)
+@@ -0,0 +1,55 @@
++package main.java.coderkim.BOJ.week05.week05_02.oneTwoThreeSum_9095;
++
++import java.util.Scanner;
++
++/**
++ @Title
++ @Since
++ @Content
++ 문제
++ 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.
++
++ 1+1+1+1
++ 1+1+2
++ 1+2+1
++ 2+1+1
++ 2+2
++ 1+3
++ 3+1
++ 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
++
++ 입력
++ 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
++
++ 출력
++ 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.
++ */
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        int T = sc.nextInt(); // 테스트 케이스의 개수
++
++        for (int t = 0; t < T; t++) {
++            int n = sc.nextInt(); // 정수 n
++
++            int[] dp = new int[n + 1];
++
++            dp[1] = 1;
++            if (n >= 2) {
++                dp[2] = 2;
++            }
++            if (n >= 3) {
++                dp[3] = 4;
++            }
++
++            for (int i = 4; i <= n; i++) {
++                dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
++            }
++
++            System.out.println(dp[n]);
++        }
++
++        sc.close();
++    }
++}
+\ No newline at end of file
+Index: src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640031)
++++ b/src/main/java/coderkim/BOJ/week05/week05_02/Tiling2xN2_11727/Main.java	(date 1705332640031)
+@@ -0,0 +1,41 @@
++package main.java.coderkim.BOJ.week05.week05_02.Tiling2xN2_11727;
++
++import java.util.Scanner;
++
++/**
++ @Title 2 X N 타일링2(11727)
++ @Since 2024.01.14
++ @Content
++ 문제
++ 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
++
++ 아래 그림은 2×17 직사각형을 채운 한가지 예이다.
++
++ 입력
++ 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
++
++ 출력
++ 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
++ */
++//TODO:동적계획법
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        int n = sc.nextInt();
++        int[] dp = new int[n + 1];
++        int mod = 10007;
++
++        dp[1] = 1;
++        if (n > 1) {
++            dp[2] = 3;
++        }
++
++        for (int i = 3; i <= n; i++) {
++            dp[i] = (dp[i - 1] + dp[i - 2] * 2) % mod;
++        }
++
++        System.out.println(dp[n]);
++        sc.close();
++    }
++}
+Index: src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java
+new file mode 100644
+--- /dev/null	(date 1705332640010)
++++ b/src/main/java/coderkim/BOJ/week04/week04_01/binaryToOctal_1373/Main.java	(date 1705332640010)
+@@ -0,0 +1,49 @@
++package main.java.coderkim.BOJ.week04.week04_01.binaryToOctal_1373;
++import java.util.Scanner;
++
++/**
++ @Title 2진수 8진수(1373)
++ @Since 2024.01.07
++ @Content 문제
++ 2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오.
++
++ 입력
++ 첫째 줄에 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다.
++
++ 출력
++ 첫째 줄에 주어진 수를 8진수로 변환하여 출력한다.
++
++ 참고 <a href="https://m.blog.naver.com/javrin4/220956809081">...</a>
++
++ */
++public class Main {
++    public static void main(String[] args) {
++        Scanner sc = new Scanner(System.in);
++
++        // 입력
++        // 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다
++        String input = sc.nextLine();
++        int length = input.length();
++        // 8진수를 담기 위한 객체
++        StringBuilder octalStringBuilder = new StringBuilder();
++        // 8진수는 2의 3제곱. 뒤에서부터 숫자를 3자리씩 묶어준 그룹을 2진수 8진수 로 변환.
++        // 모자른 자리는 0을 플러스 해준다
++        for (int i = length; i > 0; i -= 3) {
++            String group = input.substring(Math.max(i - 3, 0),i);
++            if(group.length() < 3){
++                group = "0" + group;
++            }
++            int decimal = Integer.parseInt(group, 2);
++            octalStringBuilder.append(decimal);
++        }
++
++        // 저장된 순서가 거꾸로이기 때문에 뒤집어준다.
++        String octal = octalStringBuilder.reverse().toString();
++
++        System.out.println(octal);
++
++        sc.close();
++
++
++    }
++}
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1705333704026)
+++ b/.idea/modules.xml	(date 1705333704026)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/CodingTest.iml" filepath="$PROJECT_DIR$/CodingTest.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
